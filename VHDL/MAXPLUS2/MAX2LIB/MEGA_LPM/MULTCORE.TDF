--------------------------------------------------------------------
--
--	MULTCORE	 
--
--	Copyright (C) 1991-1997 Altera Corporation
--	Any megafunction design, and related net list (encrypted or decrypted),
--	support information, device programming or simulation file, and any other
--	associated documentation or information provided by Altera or a partner
--	under Altera's Megafunction Partnership Program may be used only to
--	program PLD devices (but not masked PLD devices) from Altera.  Any other
--	use of such megafunction design, net list, support information, device
--	programming or simulation file, or any other related documentation or
--	information is prohibited for any other purpose, including, but not
--	limited to modification, reverse engineering, de-compiling, or use with
--	any other silicon devices, unless such use is explicitly licensed under
--	a separate agreement with Altera or a megafunction partner.  Title to
--	the intellectual property, including patents, copyrights, trademarks,
--	trade secrets, or maskworks, embodied in any such megafunction design,
--	net list, support information, device programming or simulation file, or
--	any other related documentation or information provided by Altera or a
--	megafunction partner, remains with Altera, the megafunction partner, or
--	their respective licensors.  No other licenses, including any licenses
--	needed under any third party's intellectual property, are provided herein.
--
--	Version 3.0
--
--------------------------------------------------------------------

--------------------------------------------------------------
-- Name : multcore.tdf										--
-- Function: This is the multiplication core subdesign. It	--
-- 			 accepts two inputs and returns their product.	--
--															--
-- Features: * Optimized for the cases where at least one	--
--			   is a constant value.							--
--			 * This design can be pipelined.				--
--			 * The parallel adder used to add partial 		--
--			   products is a CSA-based one for nonpipelined --
--			   FLEX/NORMAL and MAX cases. It's CPA-based	--
--			   for all other cases.							--
--			 * Using USE_EAB parameter it can be 			--
--			   implemented using EABs (along with parallel  --
--			   adders when necessary).						--
--------------------------------------------------------------  
INCLUDE "lpm_add_sub";
INCLUDE "csa_add";
INCLUDE "mpar_add";
INCLUDE "muleabz";
 
PARAMETERS 
(
	LPM_WIDTHA,
	LPM_WIDTHB,
	LPM_REPRESENTATION = "UNSIGNED",
	LATENCY = 0,
	ONE_INPUT_IS_CONSTANT = "NO",
	USE_EAB = "OFF",
	DEVICE_FAMILY,
	CARRY_CHAIN
);


-- A useful function ...
DEFINE   MAX(a, b) 			= a > b ? a : b;

-----------------------------------------------------
-- Parameters used in non-EAB-based implementations
-----------------------------------------------------
CONSTANT BLOCKS 			= CEIL(LPM_WIDTHA DIV 4);
CONSTANT FULL_WIDTHR 		= LPM_WIDTHA + LPM_WIDTHB;	   					    
CONSTANT CPA_LEVELS 		= LPM_WIDTHB < 2 ? 0 : CEIL(LOG2(LPM_WIDTHB));
CONSTANT TOT_LEVELS	 		= ONE_INPUT_IS_CONSTANT == "NO" ? CPA_LEVELS+1 : 
																CEIL(LOG2(BLOCKS))+3;
CONSTANT TOT_STAGES 		= ONE_INPUT_IS_CONSTANT == "NO" ? TOT_LEVELS : 
																CEIL(LOG2(BLOCKS))+1;
CONSTANT EXT_FULL_WIDTHR 	= 4*BLOCKS + LPM_WIDTHB;

-- Latency related stuff. DEC_NEED_CLOCK indicates whether the decoder stage
-- in non_EAB implemetation should be registered for pipelining. 						   					
DEFINE   MOD_DIST(n, d)		= ((2 * n) > d ? d - n : n);
DEFINE   LATENCY_MOD(k)		= ((k * (LATENCY + 1)) MOD TOT_STAGES);
CONSTANT DEC_NEED_CLK		= -((LATENCY_MOD(1) == 0) # 
							    (LATENCY_MOD(1) > LATENCY_MOD(2) & 
			  				     MOD_DIST(LATENCY_MOD(1), TOT_STAGES) < 
								 MOD_DIST(LATENCY_MOD(2), TOT_STAGES)) #
			  				    (LATENCY_MOD(1) < LATENCY_MOD(0) & 
							     MOD_DIST(LATENCY_MOD(1), TOT_STAGES) <= 
								 MOD_DIST(LATENCY_MOD(0), TOT_STAGES)));


--------------------------------------------------
-- Parameters used in EAB-based implementations
--------------------------------------------------
CONSTANT EAB_NEEDS_NO_ADDER = -((ONE_INPUT_IS_CONSTANT == "YES" & 
									LPM_WIDTHA <= 8) #
							    (ONE_INPUT_IS_CONSTANT == "NO" & 
								   (LPM_WIDTHA + LPM_WIDTHB <= 8)));

CONSTANT OPT_WIDTHA = (EAB_NEEDS_NO_ADDER > 0) ? LPM_WIDTHA :
							(ONE_INPUT_IS_CONSTANT == "YES") ? 8 : 4; 
CONSTANT A_BLOCKS 	= CEIL(LPM_WIDTHA DIV OPT_WIDTHA);
CONSTANT REM_A_BITS = (LPM_WIDTHA MOD OPT_WIDTHA > 0) ? 
							(LPM_WIDTHA MOD OPT_WIDTHA) : OPT_WIDTHA;
CONSTANT EAB_TOT_LEVELS	= CEIL(LOG2(A_BLOCKS)) + CEIL(LOG2(OPT_WIDTHA)) + 1; 
CONSTANT EAB_TOT_STAGES = 2;
CONSTANT EAB_EXT_FULL_WIDTHR = OPT_WIDTHA*A_BLOCKS + LPM_WIDTHB;

 
SUBDESIGN multcore
( 
	dataa	[LPM_WIDTHA-1..0]				: INPUT;
	datab	[LPM_WIDTHB-1..0]				: INPUT;
	clock									: INPUT = GND;
	aclr									: INPUT = GND;
 	result	[LPM_WIDTHA+LPM_WIDTHB-1..0] 	: OUTPUT;
)


VARIABLE
	
	IF (USE_EAB == "OFF") # (USE_EAB == "ON" & DEVICE_FAMILY != "FLEX10K") GENERATE
		----------------------------------------------
		-- 			Non_EAB Implementation 			--
 		----------------------------------------------	
		IF !(LPM_WIDTHB == 1 # LPM_WIDTHA == 1 # 
			(LPM_WIDTHB == 2 & LPM_WIDTHA == 2)) GENERATE

			IF ONE_INPUT_IS_CONSTANT == "YES" GENERATE
				-------------------------------------
				-- case when one input is constant --
				-------------------------------------
 				ina_reg[LPM_WIDTHA-1..0]				: NODE;
				ina_reg_clkd[3..0]						: NODE;
				inb_reg[LPM_WIDTHB+4-1..0]				: NODE;

				IF USED(clock) & (DEC_NEED_CLK == 1) GENERATE
					romout[BLOCKS-1..0][LPM_WIDTHB+4-1..0]  : DFF;
				ELSE GENERATE
					romout[BLOCKS-1..0][LPM_WIDTHB+4-1..0]  : NODE;
				END GENERATE;

				IF !(LPM_REPRESENTATION == "SIGNED" & BLOCKS == 1) GENERATE
					bnodes[15..0][LPM_WIDTHB+3..0]		: NODE;
				ELSE GENERATE
					bnodes[8..0][LPM_WIDTHB+3..0]		: NODE;
				END GENERATE;
			
				nodes_mslut[15..0][LPM_WIDTHB+3..0]		: NODE;
	
				-- Parallel adder declarations. The parallel adder used is a CSA_based
				-- adder for "non-pipelined, non-FLEX/FAST" cases and a CPA-based one
				-- for all pipelined and FLEX/FAST cases.
				IF !USED(clock) & 
				  !((DEVICE_FAMILY == "FLEX8000" # DEVICE_FAMILY == "FLEX10K") & 
					CARRY_CHAIN != "IGNORE") GENERATE
					padder	: csa_add WITH (SIZE = EXT_FULL_WIDTHR, 
											WIDTH = BLOCKS, 
											END_ADDER = 1);

				ELSE GENERATE
					padder	: mpar_add WITH (SIZE = LPM_WIDTHB+4, 
											 WIDTH = BLOCKS, 
											 REPRESENTATION = LPM_REPRESENTATION,
											 INT_LATENCY = LATENCY, 
											 LEVEL = 3, 
											 TOT_LEVELS = TOT_LEVELS, 
											 PREV_SING_SIZE = LPM_WIDTHB+4,
											 STAGE = 1, 
											 TOT_STAGES = TOT_STAGES);
				END GENERATE;
	
			ELSE GENERATE
				-----------------------------------------
				-- case when one input is not constant --
				-----------------------------------------
				IF USED(clock) & (DEC_NEED_CLK == 1) GENERATE
					decoder_node[LPM_WIDTHB-1..0][LPM_WIDTHA-1..0] : DFF;
						
				ELSE GENERATE
					IF (DEVICE_FAMILY == "FLEX8000" # DEVICE_FAMILY == "FLEX10K") & 
						CARRY_CHAIN != "IGNORE" GENERATE	
						decoder_node[LPM_WIDTHB-1..0][LPM_WIDTHA-1..0] : LCELL;
					ELSE GENERATE
						decoder_node[LPM_WIDTHB-1..0][LPM_WIDTHA-1..0] : NODE;
					END GENERATE;
				END GENERATE;
		
				IF LPM_REPRESENTATION == "SIGNED" GENERATE
	 				IF USED(clock) # 
					 ((DEVICE_FAMILY == "FLEX8000" # DEVICE_FAMILY == "FLEX10K") & 
					   CARRY_CHAIN != "IGNORE") GENERATE
						IF USED(clock) & (DEC_NEED_CLK == 1) GENERATE
							sign_ff : DFF;
						ELSE GENERATE
							sign_ff : NODE;
						END GENERATE;
					END GENERATE;
				END GENERATE;	
				
				-- parallel adder declaration
				IF !USED(clock) & 
				   !((DEVICE_FAMILY == "FLEX8000" # DEVICE_FAMILY == "FLEX10K") & 
					CARRY_CHAIN != "IGNORE") GENERATE
					IF LPM_REPRESENTATION == "UNSIGNED" GENERATE
						padder	: csa_add WITH (SIZE = FULL_WIDTHR, 
												WIDTH = LPM_WIDTHB, 
												END_ADDER = 1);
					ELSE GENERATE
						padder	: csa_add WITH (SIZE = FULL_WIDTHR, 
												WIDTH = LPM_WIDTHB+1, 
												END_ADDER = 1);
					END GENERATE;
	
				ELSE GENERATE
					padder	: mpar_add WITH (SIZE = LPM_WIDTHA+1, 
											 WIDTH = LPM_WIDTHB, 
											 REPRESENTATION = LPM_REPRESENTATION,
											 LEVEL = 1, 
											 TOT_LEVELS = TOT_LEVELS, 
											 INT_LATENCY = LATENCY, 
											 STAGE = 1,
											 TOT_STAGES = TOT_STAGES); 
				END GENERATE;
			END GENERATE;
			
		ELSE GENERATE
			IF LPM_REPRESENTATION == "SIGNED" & 
			 ((LPM_WIDTHB == 1 & LPM_WIDTHA > 2) # 
			  (LPM_WIDTHA == 1 & LPM_WIDTHB > 2)) GENERATE
				adder : lpm_add_sub WITH (LPM_WIDTH = (MAX(LPM_WIDTHA, LPM_WIDTHB)+1), 
										  LPM_PIPELINE = 0); 
			END GENERATE;				
		END GENERATE;

	ELSE GENERATE
		------------------------------------------------------
		-- 				Implementation in EABs				--
 		------------------------------------------------------	
		IF A_BLOCKS > 1 GENERATE
			IF USED(clock) & USED(aclr) GENERATE
 				 multer[A_BLOCKS-2..0] 	: muleabz WITH (WIDTHA = OPT_WIDTHA, 
														WIDTHB = LPM_WIDTHB,
														A_REPRESENTATION = "UNSIGNED",
														B_REPRESENTATION = LPM_REPRESENTATION,
														PIPELINE = LATENCY,
														INPUT_B_IS_CONSTANT = ONE_INPUT_IS_CONSTANT,
														EXT_EAB_OUT_REG = "YES",
														USE_EAB = USE_EAB);

			ELSE GENERATE
 				 multer[A_BLOCKS-2..0] 	: muleabz WITH (WIDTHA = OPT_WIDTHA, 
														WIDTHB = LPM_WIDTHB,
														A_REPRESENTATION = "UNSIGNED",
														B_REPRESENTATION = LPM_REPRESENTATION,
														PIPELINE = LATENCY,
														INPUT_B_IS_CONSTANT = ONE_INPUT_IS_CONSTANT,
														EXT_EAB_OUT_REG = "NO",
														USE_EAB = USE_EAB);
			END GENERATE;
		END GENERATE;
	
		IF USED(clock) & USED(aclr) GENERATE
			last_multer	: muleabz WITH (WIDTHA = REM_A_BITS, 
										WIDTHB = LPM_WIDTHB,
										A_REPRESENTATION = LPM_REPRESENTATION,
										B_REPRESENTATION = LPM_REPRESENTATION,
										PIPELINE = LATENCY,
										INPUT_B_IS_CONSTANT = ONE_INPUT_IS_CONSTANT,
										EXT_EAB_OUT_REG = "YES",
										USE_EAB = USE_EAB);
	
		ELSE GENERATE
			last_multer	: muleabz WITH (WIDTHA = REM_A_BITS, 
										WIDTHB = LPM_WIDTHB,
										A_REPRESENTATION = LPM_REPRESENTATION,
										B_REPRESENTATION = LPM_REPRESENTATION,
										PIPELINE = LATENCY,
										INPUT_B_IS_CONSTANT = ONE_INPUT_IS_CONSTANT,
										EXT_EAB_OUT_REG = "NO",
										USE_EAB = USE_EAB);
		END GENERATE;
 
		-- parallel adder declaration
		IF !USED(clock) & CARRY_CHAIN == "IGNORE" GENERATE
			par_adder	: csa_add WITH (SIZE = EAB_EXT_FULL_WIDTHR, 
										WIDTH = A_BLOCKS, 
										END_ADDER = 1);

		ELSE GENERATE
			par_adder	: mpar_add WITH (SIZE = LPM_WIDTHB + OPT_WIDTHA, 
										 WIDTH = A_BLOCKS, 
										 REPRESENTATION = LPM_REPRESENTATION,
										 INT_LATENCY = 1,
										 LEVEL = CEIL(LOG2(OPT_WIDTHA)) + 1, 
										 TOT_LEVELS = EAB_TOT_LEVELS, 
										 PREV_SING_SIZE = LPM_WIDTHB + OPT_WIDTHA,
										 STAGE = 1, 
										 TOT_STAGES = EAB_TOT_STAGES);
		END GENERATE;
	END GENERATE;
	

BEGIN
  
	IF (USE_EAB == "OFF") # (USE_EAB == "ON" & DEVICE_FAMILY != "FLEX10K") GENERATE
		----------------------------------------------
		-- 			Non_EAB Implementation 			--
 		----------------------------------------------	
 		-- special cases	
		IF LPM_WIDTHA == 1 GENERATE
			IF LPM_REPRESENTATION == "UNSIGNED" GENERATE
				result[] = (GND, dataa[0] & datab[]);
				
			ELSE GENERATE
				IF LPM_WIDTHB <= 2 GENERATE
					IF LPM_WIDTHB == 1 GENERATE
						result[] = (GND, dataa[0] & datab[0]);
							
					ELSE GENERATE
						IF LPM_WIDTHB == 2 GENERATE 
							result[0] = dataa[0] & datab[0];
							result[1] = (!datab[0] $ !datab[1]) & dataa[0];
							result[2] = datab[0] & !datab[1] & dataa[0];		
						END GENERATE;
					END GENERATE;
						
				ELSE GENERATE
					adder.dataa[0] = dataa[0];
					adder.dataa[LPM_WIDTHB..1] = GND;
					adder.datab[LPM_WIDTHB-1..0] = !datab[] & dataa[0];
					adder.datab[LPM_WIDTHB] = !datab[LPM_WIDTHB-1] & dataa[0];
					result[] = adder.result[]; 
				END GENERATE;
			END GENERATE;
				
		ELSE GENERATE
			IF LPM_WIDTHB == 1 GENERATE
				IF LPM_REPRESENTATION == "UNSIGNED" GENERATE
					result[] = (GND, dataa[] & datab[0]);
				
				ELSE GENERATE
					IF LPM_WIDTHA == 2 GENERATE 
						result[0] = dataa[0] & datab[];
						result[1] = (!dataa[0] $ !dataa[1]) & datab[0];
						result[2] = dataa[0] & !dataa[1] & datab[0];		
					
					ELSE GENERATE
						adder.dataa[LPM_WIDTHA-1..0] = !dataa[] & datab[0];
						adder.dataa[LPM_WIDTHA] = !dataa[LPM_WIDTHA-1] & datab[0];
						adder.datab[0] = datab[0];
						adder.datab[LPM_WIDTHA..1] = GND;
						result[] = adder.result[]; 
					END GENERATE;
				END GENERATE;
		
			ELSE GENERATE
				IF (LPM_WIDTHB == 2) & (LPM_WIDTHA == 2) GENERATE
					IF LPM_REPRESENTATION == "UNSIGNED" GENERATE	 
						result[0] =   dataa[0] & datab[0];
						result[1] =  (dataa[1] & datab[0]) $ (dataa[0] & datab[1]);
						result[2] = ((dataa[1] & datab[0]) & (dataa[0] & datab[1])) $ (dataa[1] & datab[1]);
						result[3] = ((dataa[1] & datab[0]) & (dataa[0] & datab[1])) & (dataa[1] & datab[1]);
									
					ELSE GENERATE
						result[0] =  dataa[0] & datab[0];
						result[1] = (dataa[1] & datab[0]) $ (!dataa[0] & datab[1]) $ datab[1];
						result[2] = (dataa[1] & datab[0]) $ (!dataa[1] & datab[1]) $
									(!dataa[0] & datab[1] # dataa[1] & datab[0] & datab[1]);
						result[3] = ((dataa[1] & datab[0]) $ (!dataa[1] & datab[1])) $ 
									(!dataa[0] & dataa[1] & datab[0] & datab[1] # 
									  dataa[1] & datab[0] & datab[1] # !dataa[0] & !dataa[1] & datab[1]);
					END GENERATE;
					
				ELSE GENERATE   
					-- The remaining cases will be handled by a parallel adder	
					IF ONE_INPUT_IS_CONSTANT == "YES" GENERATE
						-------------------------------------
						-- case when one input is constant --
						-------------------------------------
						ina_reg[LPM_WIDTHA-1..0] = dataa[];
 						IF USED(clock) & (DEC_NEED_CLK == 1) GENERATE
							romout[][].(clk, clrn) = (clock, !aclr);
						END GENERATE;

						-- Perform sign extension or zero padding on datab to
						-- add the 4 additional bits needed in a 4 x len(datab) 
						-- multiplication. This is neccessary when later we add
						-- multiples of datab together.  
						IF LPM_REPRESENTATION == "UNSIGNED" GENERATE
							inb_reg[] = (GND, GND, GND, GND, datab[]);
						ELSE GENERATE
							inb_reg[] = (datab[LPM_WIDTHB-1], datab[LPM_WIDTHB-1], 
										 datab[LPM_WIDTHB-1], datab[LPM_WIDTHB-1], datab[]);
						END GENERATE;

						-- Generate nodes that represent the 16 multiples of datab
						-- The first 8 multiples are shared between signed and unsigned cases:
						bnodes[0][]  = GND;										--  0 x b
						bnodes[1][]  = inb_reg[];								--  1 x b
						bnodes[2][]  = (inb_reg[LPM_WIDTHB+2..0], GND);			--  2 x b
						bnodes[3][]  = bnodes[1][] + bnodes[2][];				--  3 x b
						bnodes[4][]  = (inb_reg[LPM_WIDTHB+1..0], GND, GND);	--  4 x b
						bnodes[5][]  = bnodes[4][] + bnodes[1][];				--  5 x b
						bnodes[6][]  = bnodes[4][] + bnodes[2][];				--  6 x b
						bnodes[7][]  = bnodes[6][] + bnodes[1][];				--  7 x b
						bnodes[8][]  = (inb_reg[LPM_WIDTHB..0], GND, GND, GND);	--  8 x b
		
						IF LPM_REPRESENTATION == "UNSIGNED" GENERATE
							-- For the unsigned case, continue with the remaining multiples
							-- [9-15]xdatab
							bnodes[9][]  = bnodes[8][]  + bnodes[1][];			--  9 x b
							bnodes[10][] = bnodes[9][]  + bnodes[1][];			-- 10 x b
							bnodes[11][] = bnodes[10][] + bnodes[1][];			-- 11 x b
							bnodes[12][] = bnodes[11][] + bnodes[1][];			-- 12 x b
							bnodes[13][] = bnodes[12][] + bnodes[1][];			-- 13 x b
							bnodes[14][] = bnodes[13][] + bnodes[1][];			-- 14 x b
							bnodes[15][] = bnodes[14][] + bnodes[1][];			-- 15 x b
							
							-- In the unsigned case, all lookup tables are identical ...
 							nodes_mslut[][] = bnodes[][];
							
						ELSE GENERATE
							-- In the signed case, the lookup table for the chunk containing
							-- the sign bit of dataa is different from the other (middle bits)
							-- ones and, thus, one has to generate the negative multiples of
							-- datab for that lookup table. Also, if middle bits exist,
							-- one has to generate the "unsigned" lookup tables as well.
							nodes_mslut[7..0][] = bnodes[7..0][];

							nodes_mslut[8][]  = 0 - bnodes[8][];				-- -8 x b
							nodes_mslut[9][]  = 0 - bnodes[7][];				-- -7 x b
							nodes_mslut[10][] = 0 - bnodes[6][];				-- -6 x b
							nodes_mslut[11][] = 0 - bnodes[5][];				-- -5 x b
							nodes_mslut[12][] = 0 - bnodes[4][];				-- -4 x b
							nodes_mslut[13][] = 0 - bnodes[3][];				-- -3 x b
							nodes_mslut[14][] = 0 - bnodes[2][];				-- -2 x b
							nodes_mslut[15][] = 0 - bnodes[1][]; 				-- -1 x b
							
							IF BLOCKS > 1 GENERATE
								bnodes[9][]  = bnodes[8][]  + bnodes[1][];		--  9 x b
								bnodes[10][] = bnodes[9][]  + bnodes[1][];		-- 10 x b
								bnodes[11][] = bnodes[10][] + bnodes[1][];		-- 11 x b
								bnodes[12][] = bnodes[11][] + bnodes[1][];		-- 12 x b
								bnodes[13][] = bnodes[12][] + bnodes[1][];		-- 13 x b
								bnodes[14][] = bnodes[13][] + bnodes[1][];		-- 14 x b
								bnodes[15][] = bnodes[14][] + bnodes[1][];		-- 15 x b
							END GENERATE;
						END GENERATE;
			
						-- romout[I][] nodes are placeholders for outputs of the "I"th
						-- lookup table. These nodes will eventually get connected to
						-- corresponding data ports of the parallel adder. Note that
						-- a 4-bit chunk of dataa is addressing (looking up) its
						-- corresponding lookup table.
						IF BLOCKS > 1 GENERATE
							FOR I IN 0 TO BLOCKS-2 GENERATE
								CASE ina_reg[(i+1)*4-1..i*4] IS
									WHEN  0 => romout[i][] = bnodes[0][];
									WHEN  1 => romout[i][] = bnodes[1][];
									WHEN  2 => romout[i][] = bnodes[2][];
									WHEN  3 => romout[i][] = bnodes[3][];
									WHEN  4 => romout[i][] = bnodes[4][];
									WHEN  5 => romout[i][] = bnodes[5][];
									WHEN  6 => romout[i][] = bnodes[6][];
									WHEN  7 => romout[i][] = bnodes[7][];
									WHEN  8 => romout[i][] = bnodes[8][];
									WHEN  9 => romout[i][] = bnodes[9][];
									WHEN 10 => romout[i][] = bnodes[10][];
									WHEN 11 => romout[i][] = bnodes[11][];
									WHEN 12 => romout[i][] = bnodes[12][];
									WHEN 13 => romout[i][] = bnodes[13][];
									WHEN 14 => romout[i][] = bnodes[14][];
									WHEN 15 => romout[i][] = bnodes[15][];
								END CASE;
							END GENERATE;
						END GENERATE;
	
						-- This section is dealing with the last (leftmost) chunk of dataa which,
						-- for signed cases, contains the sign bit as well and thus needs special
						-- attention. First, if the chunk is not a 4-bit one, sign extend or 
						-- zero-pad it. Second, use the signed lookup table in unsigned cases.
						ina_reg_clkd[LPM_WIDTHA-(BLOCKS-1)*4-1..0] = ina_reg[LPM_WIDTHA-1..(BLOCKS-1)*4];
						IF (LPM_WIDTHA MOD 4) != 0 GENERATE
							IF LPM_REPRESENTATION == "UNSIGNED" GENERATE
								ina_reg_clkd[3..LPM_WIDTHA-1-(BLOCKS-1)*4] = GND;
							ELSE GENERATE
								ina_reg_clkd[3..LPM_WIDTHA-1-(BLOCKS-1)*4] = ina_reg[LPM_WIDTHA-1];
							END GENERATE;
						END GENERATE;
	
						CASE ina_reg_clkd[] IS
							WHEN  0 => romout[BLOCKS-1][] = nodes_mslut[0][];
							WHEN  1 => romout[BLOCKS-1][] = nodes_mslut[1][];
							WHEN  2 => romout[BLOCKS-1][] = nodes_mslut[2][];
							WHEN  3 => romout[BLOCKS-1][] = nodes_mslut[3][];
							WHEN  4 => romout[BLOCKS-1][] = nodes_mslut[4][];
							WHEN  5 => romout[BLOCKS-1][] = nodes_mslut[5][];
							WHEN  6 => romout[BLOCKS-1][] = nodes_mslut[6][];
							WHEN  7 => romout[BLOCKS-1][] = nodes_mslut[7][];
							WHEN  8 => romout[BLOCKS-1][] = nodes_mslut[8][];
							WHEN  9 => romout[BLOCKS-1][] = nodes_mslut[9][];
							WHEN 10 => romout[BLOCKS-1][] = nodes_mslut[10][];
							WHEN 11 => romout[BLOCKS-1][] = nodes_mslut[11][];
							WHEN 12 => romout[BLOCKS-1][] = nodes_mslut[12][];
							WHEN 13 => romout[BLOCKS-1][] = nodes_mslut[13][];
							WHEN 14 => romout[BLOCKS-1][] = nodes_mslut[14][];
							WHEN 15 => romout[BLOCKS-1][] = nodes_mslut[15][];
						END CASE;
	
						-- Connecting the outputs of lookup tables to the parallel adder
						IF !USED(clock) & !((DEVICE_FAMILY == "FLEX8000" # 
						 	DEVICE_FAMILY == "FLEX10K") & CARRY_CHAIN != "IGNORE") GENERATE

							IF LPM_REPRESENTATION == "UNSIGNED" GENERATE	
								padder.data[0][LPM_WIDTHB+4-1..0] = romout[0][];
		
								IF BLOCKS > 1 GENERATE
									padder.data[0][EXT_FULL_WIDTHR-1..LPM_WIDTHB+4] = GND;
									IF BLOCKS > 2 GENERATE	
										FOR I IN 1 TO BLOCKS-2 GENERATE
											padder.data[I][4*I-1..0] = GND;
											padder.data[I][4*I+LPM_WIDTHB+4-1..4*I] = romout[I][];
											padder.data[I][EXT_FULL_WIDTHR-1..4*I+LPM_WIDTHB+4] = GND;
										END GENERATE;
									END GENERATE;
 		
									padder.data[BLOCKS-1][4*(BLOCKS-1)-1..0] = GND;
									padder.data[BLOCKS-1][EXT_FULL_WIDTHR-1..4*(BLOCKS-1)] = romout[BLOCKS-1][];
								END GENERATE;		
			
							ELSE GENERATE
								padder.data[0][LPM_WIDTHB+4-1..0] = romout[0][];
		
								IF BLOCKS > 1 GENERATE
									padder.data[0][EXT_FULL_WIDTHR-1..LPM_WIDTHB+4] = romout[0][LPM_WIDTHB+4-1];
									IF BLOCKS > 2 GENERATE	
										FOR I IN 1 TO BLOCKS-2 GENERATE
											padder.data[I][4*I-1..0] = GND;
											padder.data[I][4*I+LPM_WIDTHB+4-1..4*I] = romout[I][];
											padder.data[I][EXT_FULL_WIDTHR-1..4*I+LPM_WIDTHB+4] = romout[I][LPM_WIDTHB+4-1];
										END GENERATE;
									END GENERATE;
 		
									padder.data[BLOCKS-1][4*(BLOCKS-1)-1..0] = GND;
									padder.data[BLOCKS-1][4*(BLOCKS-1)+LPM_WIDTHB+4-1..4*(BLOCKS-1)] = romout[BLOCKS-1][];
								END GENERATE;		
		
 							END GENERATE;

						ELSE GENERATE
							FOR I IN 0 TO BLOCKS-1 GENERATE
								padder.data[I][] = romout[I][];
								IF USED(clock) GENERATE
									padder.(clk, aclr) = (clock, aclr);
								END GENERATE;
							END GENERATE;
						END GENERATE;
						result[] = padder.result[FULL_WIDTHR-1..0];
	
					ELSE GENERATE
						-----------------------------------------
						-- case when one input is not constant --
						-----------------------------------------
						-- The decoder stage
						IF LPM_REPRESENTATION == "UNSIGNED" GENERATE		
							FOR I IN 0 TO LPM_WIDTHB-1 GENERATE
								decoder_node[I][] = dataa[] & datab[I]; 
							END GENERATE;
			
						ELSE GENERATE
							FOR I IN 0 TO LPM_WIDTHB-2 GENERATE
								decoder_node[I][] = dataa[] & datab[I]; 
							END GENERATE;
				
							decoder_node[LPM_WIDTHB-1][] = !dataa[] & datab[LPM_WIDTHB-1];
						END GENERATE;
			
						IF USED(clock) & (DEC_NEED_CLK == 1) GENERATE
							decoder_node[][].(clk, clrn) = (clock, !aclr);
						END GENERATE;
		
						-- Connecting outputs of decoders to the parallel adder
						IF !USED(clock) & !((DEVICE_FAMILY == "FLEX8000" # DEVICE_FAMILY == "FLEX10K") & 
							CARRY_CHAIN != "IGNORE") GENERATE
							IF LPM_REPRESENTATION == "UNSIGNED" GENERATE	
								-- These cases use the CSA-based adder scheme.
								padder.data[0][LPM_WIDTHA-1..0] = decoder_node[0][];
								padder.data[0][FULL_WIDTHR-1..LPM_WIDTHA] = GND;
			
								IF LPM_WIDTHB > 1 GENERATE
									IF LPM_WIDTHB > 2 GENERATE	
										FOR I IN 1 TO LPM_WIDTHB-2 GENERATE
											padder.data[I][I-1..0] = GND;
											padder.data[I][I+LPM_WIDTHA-1..I] = decoder_node[I][];
											padder.data[I][FULL_WIDTHR-1..I+LPM_WIDTHA] = GND;
										END GENERATE;
									END GENERATE;
	 		
									padder.data[LPM_WIDTHB-1][LPM_WIDTHB-2..0] = GND;
									padder.data[LPM_WIDTHB-1][FULL_WIDTHR-2..LPM_WIDTHB-1] = 
																	decoder_node[LPM_WIDTHB-1][];
									padder.data[LPM_WIDTHB-1][FULL_WIDTHR-1] = GND;
								END GENERATE;		
			
							ELSE GENERATE
								padder.data[0][LPM_WIDTHA-1..0] = decoder_node[0][];
								padder.data[0][FULL_WIDTHR-1..LPM_WIDTHA] = 
																	decoder_node[0][LPM_WIDTHA-1];
		
								IF LPM_WIDTHB > 1 GENERATE
									IF LPM_WIDTHB > 2 GENERATE	
										FOR I IN 1 TO LPM_WIDTHB-2 GENERATE
											padder.data[I][I-1..0] = GND;
											padder.data[I][I+LPM_WIDTHA-1..I] = decoder_node[I][];
											padder.data[I][FULL_WIDTHR-1..I+LPM_WIDTHA] =  
																	decoder_node[I][LPM_WIDTHA-1];
										END GENERATE;
									END GENERATE;
	 		
									padder.data[LPM_WIDTHB-1][LPM_WIDTHB-2..0] = GND;
									padder.data[LPM_WIDTHB-1][FULL_WIDTHR-2..LPM_WIDTHB-1] = 
																	decoder_node[LPM_WIDTHB-1][];
									padder.data[LPM_WIDTHB-1][FULL_WIDTHR-1] = decoder_node[LPM_WIDTHB-1][LPM_WIDTHA-1];
		
									padder.data[LPM_WIDTHB][LPM_WIDTHB-2..0] = GND;
									padder.data[LPM_WIDTHB][LPM_WIDTHB-1] = datab[LPM_WIDTHB-1];
									padder.data[LPM_WIDTHB][FULL_WIDTHR-1..LPM_WIDTHB] = GND;
		
								END GENERATE;		
							END GENERATE;
		
	 					ELSE GENERATE 
							-- All remaining cases use the FLEX/FAST CPA_based parallel adder scheme.
							IF LPM_REPRESENTATION == "UNSIGNED" GENERATE	
								FOR I IN 0 TO LPM_WIDTHB-1 GENERATE
									padder.data[I][LPM_WIDTHA-1..0] = decoder_node[I][];
								END GENERATE;
		
								IF USED(clock) GENERATE
									padder.(clk, aclr) = (clock, aclr);
								END GENERATE;
								
							ELSE GENERATE
								FOR I IN 0 TO LPM_WIDTHB-1 GENERATE
									padder.data[I][LPM_WIDTHA-1..0] = decoder_node[I][];
								END GENERATE;
		
								sign_ff = datab[LPM_WIDTHB-1];
								padder.cin = sign_ff;
		
								IF USED(clock) GENERATE
									padder.(clk, aclr) = (clock, aclr);
									IF DEC_NEED_CLK == 1 GENERATE
										sign_ff.(clk, clrn) =  (clock, !aclr);
									END GENERATE;
								END GENERATE;
							END GENERATE;
						END GENERATE;
		
 						result[] = padder.result[FULL_WIDTHR-1..0];
	 				END GENERATE;
			 	END GENERATE;
	 		END GENERATE;				
	 	END GENERATE;

	ELSE GENERATE
		----------------------------------------------
		-- 			EABS-based Implementation 		--
 		----------------------------------------------
  		-- If have more than OPT_WIDTHA bits, then we have full groups 
		-- of OPT_WIDTHA bits each. In these cases, we always need more than
		-- one EAB and thus OPT_A_WIDTH will be either 4 or 8.
 		IF A_BLOCKS > 1 GENERATE
			FOR I IN 0 TO A_BLOCKS-2 GENERATE
			 	multer[I].dataa[] = dataa[(I+1)*OPT_WIDTHA-1..I*OPT_WIDTHA];
 				multer[I].datab[] = datab[];
 			END GENERATE;
		END GENERATE;

		-- The last remaining bit group (possibly less than OPT_WIDTHA bits). This
		-- case also handles the odd-shaped multipliers by using a non-4/8 size for
		-- OPT_A_WIDTH. Note that the parallel_adder handles "single-input" cases
		-- as well and simply bypasses the input to its output. This reduces our
		-- hassle of taking care of the special case of a single EAB with no 
		-- parallel_adder needed.
	 	last_multer.dataa[] = dataa[LPM_WIDTHA-1..LPM_WIDTHA-REM_A_BITS];
	 	last_multer.datab[] = datab[];

		-- Connecting the outputs of EAB lookup tables to the parallel adder
		-- If CSA adders are used, sign extensions will be performed. Else, direct
		-- connections to inputs of the parallel adder are made.
		IF !USED(clock) & !(DEVICE_FAMILY == "FLEX10K" & CARRY_CHAIN != "IGNORE") GENERATE
			IF LPM_REPRESENTATION == "UNSIGNED" GENERATE	

				IF A_BLOCKS > 1 GENERATE
					par_adder.data[0][LPM_WIDTHB+OPT_WIDTHA-1..0] = multer[0].result[LPM_WIDTHB+OPT_WIDTHA-1..0];
					par_adder.data[0][EAB_EXT_FULL_WIDTHR-1..LPM_WIDTHB+OPT_WIDTHA] = GND;
					IF A_BLOCKS > 2 GENERATE	
						FOR I IN 1 TO A_BLOCKS-2 GENERATE
							par_adder.data[I][OPT_WIDTHA*I-1..0] = GND;
							par_adder.data[I][OPT_WIDTHA*I+LPM_WIDTHB+OPT_WIDTHA-1..OPT_WIDTHA*I] = multer[I].result[LPM_WIDTHB+OPT_WIDTHA-1..0];
							par_adder.data[I][EAB_EXT_FULL_WIDTHR-1..OPT_WIDTHA*I+LPM_WIDTHB+OPT_WIDTHA] = GND;
						END GENERATE;
					END GENERATE;
 					par_adder.data[A_BLOCKS-1][OPT_WIDTHA*(A_BLOCKS-1)-1..0] = GND;
				END GENERATE;

				par_adder.data[A_BLOCKS-1][LPM_WIDTHB+REM_A_BITS+OPT_WIDTHA*(A_BLOCKS-1)-1..OPT_WIDTHA*(A_BLOCKS-1)] = 
											last_multer.result[];	
				IF REM_A_BITS < OPT_WIDTHA GENERATE 
					par_adder.data[A_BLOCKS-1][EAB_EXT_FULL_WIDTHR-1..LPM_WIDTHB+REM_A_BITS+OPT_WIDTHA*(A_BLOCKS-1)] = GND;
				END GENERATE;
 
			ELSE GENERATE

				IF A_BLOCKS > 1 GENERATE
					par_adder.data[0][LPM_WIDTHB+OPT_WIDTHA-1..0] = multer[0].result[LPM_WIDTHB+OPT_WIDTHA-1..0];
					par_adder.data[0][EAB_EXT_FULL_WIDTHR-1..LPM_WIDTHB+OPT_WIDTHA] = multer[0].result[LPM_WIDTHB+OPT_WIDTHA-1];
					IF A_BLOCKS > 2 GENERATE	
						FOR I IN 1 TO A_BLOCKS-2 GENERATE
							par_adder.data[I][OPT_WIDTHA*I-1..0] = GND;
							par_adder.data[I][OPT_WIDTHA*I+LPM_WIDTHB+OPT_WIDTHA-1..OPT_WIDTHA*I] = multer[I].result[LPM_WIDTHB+OPT_WIDTHA-1..0];
							par_adder.data[I][EAB_EXT_FULL_WIDTHR-1..OPT_WIDTHA*I+LPM_WIDTHB+OPT_WIDTHA] = multer[I].result[LPM_WIDTHB+OPT_WIDTHA-1];
						END GENERATE;
					END GENERATE;
					par_adder.data[A_BLOCKS-1][OPT_WIDTHA*(A_BLOCKS-1)-1..0] = GND;
 				END GENERATE;		
	
				par_adder.data[A_BLOCKS-1][LPM_WIDTHB+REM_A_BITS+OPT_WIDTHA*(A_BLOCKS-1)-1..OPT_WIDTHA*(A_BLOCKS-1)] = 
											last_multer.result[];
				IF REM_A_BITS < OPT_WIDTHA GENERATE 
					par_adder.data[A_BLOCKS-1][EAB_EXT_FULL_WIDTHR-1..LPM_WIDTHB+REM_A_BITS+OPT_WIDTHA*(A_BLOCKS-1)] = 
											last_multer.result[LPM_WIDTHB+REM_A_BITS-1];
				END GENERATE;
 			END GENERATE;
		
		ELSE GENERATE
	 		IF A_BLOCKS > 1 GENERATE
				FOR I IN 0 TO A_BLOCKS-2 GENERATE
 		 			par_adder.data[I][] = multer[I].result[LPM_WIDTHB+OPT_WIDTHA-1..0];
				END GENERATE;
			END GENERATE;

		 	par_adder.data[A_BLOCKS-1][REM_A_BITS+LPM_WIDTHB-1..0] = last_multer.result[];
		
			IF (REM_A_BITS < OPT_WIDTHA) & LPM_REPRESENTATION == "SIGNED" GENERATE
		  		par_adder.data[A_BLOCKS-1][LPM_WIDTHB+OPT_WIDTHA-1..LPM_WIDTHB+REM_A_BITS] = 
									last_multer.result[REM_A_BITS+LPM_WIDTHB-1];
		 	END GENERATE;
		END GENERATE;

		result[] = par_adder.result[LPM_WIDTHA+LPM_WIDTHB-1..0];
	 
		-- clock/aclr connections
		IF USED(clock) GENERATE
			IF USED(aclr) GENERATE
				IF A_BLOCKS > 1 GENERATE
					multer[].(clock, aclr) = (clock, aclr);
				END GENERATE;
				last_multer.(clock, aclr) = (clock, aclr);
	
			ELSE GENERATE
				IF A_BLOCKS > 1 GENERATE
					multer[].clock = clock;
				END GENERATE;
				last_multer.clock = clock;
			END GENERATE;
		END GENERATE;
 	END GENERATE;
END;


