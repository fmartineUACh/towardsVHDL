<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0048)http://det.bp.ehu.es/vhdl/pagina/completo/02.htm -->
<HTML><HEAD><TITLE>Lección 2: Unidades Básicas de Diseño.</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1252">
<META content="Daniel Jiménez Iglesias          danieljimenez@mailcity.com" 
name=Author>
<META content="Daniel Jiménez Iglesias y Juan Carlos Cárdenas Bonelli" 
name=Author>
<META content="Juan Carlos Cárdenas Bonelli     juanky.cardenas@mailcity.com" 
name=Author>
<META content="MSHTML 5.50.4134.100" name=GENERATOR></HEAD>
<BODY bgProperties=fixed 
background="Lección 2 Unidades Básicas de Diseño_archivos/fondo01.jpg">
<P align=center><FONT face=Tahoma color=#000080><BIG><U><BIG><BIG>Unidades 
Básicas de Diseño</BIG></BIG></U></BIG></FONT></P>
<TABLE width="100%" border=0>
  <TBODY>
  <TR>
    <TD width="22%"></TD>
    <TD width="67%">&nbsp;
      <UL>
        <LI>
        <P align=left><A 
        href="http://det.bp.ehu.es/vhdl/pagina/completo/02.htm#1"><FONT 
        face=Tahoma color=#000080><U><BIG>Como se declara una 
        Entidad</BIG></U></FONT></A></P>
        <LI>
        <P align=left><A 
        href="http://det.bp.ehu.es/vhdl/pagina/completo/02.htm#4"><FONT 
        face=Tahoma color=#000080 size=3><U><BIG>Como se declara una 
        Arquitectura</BIG></U></FONT></A></P>
        <LI>
        <P align=left><FONT face=Tahoma color=#000080><U><BIG><A 
        href="http://det.bp.ehu.es/vhdl/pagina/completo/02.htm#6">Paquetes</A> 
        </BIG></U></FONT></P>
        <LI>
        <P align=left><FONT face=Tahoma color=#000080><A 
        href="http://det.bp.ehu.es/vhdl/pagina/completo/02.htm#7"><U><BIG>Librería 
        LPM (Library of parametrized</BIG><BR></U></A><BIG>&nbsp;&nbsp; <A 
        href="http://det.bp.ehu.es/vhdl/pagina/completo/02.htm#7"><U>modules)</U></A></BIG></FONT></P></LI></UL></TD>
    <TD width="11%"></TD></TR></TBODY></TABLE>
<P align=left>&nbsp;</P>
<HR>

<TABLE cellSpacing=0 width="100%" border=0>
  <TBODY>
  <TR>
    <TD width="74%"><SMALL><A name=entidad></A><A name=1></A></SMALL><FONT 
      face=Tahoma color=#000080><U><BIG>Como se declara una 
      Entidad</BIG></U></FONT></TD>
    <TD width="26%">
      <P align=right><A 
      href="http://det.bp.ehu.es/vhdl/pagina/completo/02.htm#top"><IMG height=42 
      alt="Inicio de la página" 
      src="Lección 2 Unidades Básicas de Diseño_archivos/image01.gif" width=59 
      border=0></A></P></TD></TR></TBODY></TABLE>
<P><FONT face="MS Sans Serif" size=3>&nbsp;&nbsp; En la declaración de 
entidades, se definen las entradas, salidas y tamaño de un circuito, 
explicitando cuales son, de qué tamaño (de 0 a n bits), <A 
href="http://det.bp.ehu.es/vhdl/pagina/completo/02.htm#modos">modo</A> (entrada, 
salida, ...) y <A 
href="http://det.bp.ehu.es/vhdl/pagina/completo/02.htm#tipos">tipo</A> (integer, 
bit,...) . Las entidades pueden definir bien las entradas y salidas de un diseño 
más grande o las entradas y salidas de un chip directamente.&nbsp; La 
declaración de entidades es análoga al símbolo esquemático de lo que queremos 
implementar, el cual describe las conexiones de un componente al resto del 
proyecto, es decir, si hay una entrada o puerto de 8 bits, o dos salidas o 
puertos de 4 bits, etc. La declaración de entidades tiene la siguiente 
forma:</FONT></P>
<TABLE height=238 width="100%" bgColor=#ffffff border=0>
  <TBODY>
  <TR>
    <TD width="45%" height=31><FONT face="OCR A Extended" 
      size=3><STRONG>entity</STRONG> circuito_a <STRONG>is</STRONG></FONT></TD>
    <TD width="55%" height=31><FONT face=Verdana size=2>Cabecera del 
      programa</FONT></TD></TR>
  <TR>
    <TD borderColor=#0000ff width="45%" height=33><FONT face="OCR A Extended" 
      size=3><STRONG>port</STRONG>(</FONT></TD>
    <TD borderColor=#0000ff width="55%" height=33><FONT face=Verdana size=2>Se 
      indica que a continuación viene los puertos (o grupos señales) de entrada 
      y/o salida</FONT></TD></TR>
  <TR>
    <TD width="45%" height=90><FONT face="OCR A Extended" size=3>-- puertos de 
      entradas<BR>-- puertos de salidas<BR>-- puertos de I/O<BR>-- puertos de 
      buffers</FONT></TD>
    <TD width="55%" height=90><FONT face=Verdana size=2>Aquí se declaran las 
      entradas y/o salidas con la sintaxis que se verá a continuación. Las 
      líneas empezadas por dos guiones son ignoradas por el compilador. Así 
      mismo, recordamos que el compilador no distingue las mayúsculas de las 
      minúsculas</FONT></TD></TR>
  <TR>
    <TD width="45%" height=60><FONT face="OCR A Extended" 
      size=3>);<BR><STRONG>end</STRONG> circuito_a;</FONT></TD>
    <TD width="55%" height=60><FONT face=Verdana size=2>Se indica que se ha 
      acabado la declaración de puertos de entrada y/o salida, y que se ha 
      acabado la entidad</FONT></TD></TR></TBODY></TABLE>
<P>&nbsp;&nbsp;&nbsp; <FONT face="MS Sans Serif">Como hemos dicho, cada señal en 
una declaración de entidad está referida a un puerto (o grupo de señales), el 
cual es análogo a un(os) pin(es) del símbolo esquemático. Un puerto es un objeto 
de información, el cual, puede ser usado en expresiones y al cual se le pueden 
asignar valores. A cada puerto se le </FONT><FONT face="MS Sans Serif" 
size=3>debe asignar un nombre válido. A continuación se exponen algunos 
ejemplos:&nbsp; </FONT></P>
<TABLE height=253 width="100%" bgColor=#ffffff border=0>
  <TBODY>
  <TR>
    <TD width="52%" height=30><FONT face="OCR A Extended" 
      size=3>nombre_variable: modo tipo;</FONT></TD>
    <TD width="48%" height=30><FONT face=Verdana size=2>Forma genérica de 
      designar un puerto</FONT></TD></TR>
  <TR>
    <TD width="52%" height=40><FONT face="OCR A Extended" size=3>puertoa: 
      <STRONG>in</STRONG> <STRONG>bit</STRONG>;</FONT></TD>
    <TD width="48%" height=40><FONT face=Verdana size=2>El primer puerto es un 
      bit de entrada, y su nombre es "puertoa"</FONT></TD></TR>
  <TR>
    <TD width="52%" height=41><FONT face="OCR A Extended" size=3>puertob: 
      <STRONG>in</STRONG> <STRONG>bit_vector</STRONG>(0 <STRONG>to</STRONG> 
      7);</FONT></TD>
    <TD width="48%" height=41><FONT face=Verdana size=2>El segundo puerto es 
      un vector de 8 bits de entrada siendo el MSB el puertob(0) y el LSB el 
      puertob(7)</FONT></TD></TR>
  <TR>
    <TD width="52%" height=42><FONT face="OCR A Extended" size=3>puertoc: 
      <STRONG>out</STRONG> <STRONG>bit_vector</STRONG>(3 <STRONG>downto</STRONG> 
      0);</FONT></TD>
    <TD width="48%" height=42><FONT face=Verdana size=2>El tercer puerto es un 
      vector de 4 bits de salida siendo el MSB el puertoc(3) y el LSB el 
      puertoc(0)</FONT></TD></TR>
  <TR>
    <TD width="52%" height=42><FONT face="OCR A Extended" size=3>puertod: 
      <STRONG>buffer</STRONG> <STRONG>bit</STRONG>;</FONT></TD>
    <TD width="48%" height=42><FONT face=Verdana size=2>El cuarto puerto es un 
      buffer de un solo bit, cuyo nombre es "puertod"</FONT></TD></TR>
  <TR>
    <TD width="52%" height=34><FONT face="OCR A Extended" size=3>puertoe: 
      <STRONG>inout</STRONG> <STRONG>std_logic</STRONG>;</FONT></TD>
    <TD width="48%" height=34><FONT face=Verdana size=2>El quinto puerto es 
      una entrada/salida del tipo estándar logic de un solo 
  bit</FONT></TD></TR></TBODY></TABLE>
<P><FONT face="MS Sans Serif">&nbsp;&nbsp;&nbsp; <A name=modos></A><A 
name=2></A>Como se puede deducir de los ejemplos anteriores, seguido del <A 
href="http://det.bp.ehu.es/vhdl/pagina/completo/02.htm#no validos">nombre del 
puerto</A> y separado de éste por dos puntos, se debe indicar el tipo de puerto. 
El modo describe la dirección en la cual la información es transmitida a través 
del puerto: in, out, buffer e inout. Si no se especifica nada, se asume que el 
puerto es del modo in.</FONT><FONT size=3></P>
<BLOCKQUOTE>
  <P align=left><IMG height=20 alt="item01.gif (370 bytes)" 
  src="Lección 2 Unidades Básicas de Diseño_archivos/item01.gif" width=20><FONT 
  face="MS Sans Serif">Modo </FONT></FONT><B><FONT face="MS Sans Serif" 
  color=#990000 size=3>i</FONT><FONT size=3><FONT face="MS Sans Serif"><FONT 
  size=3><FONT color=#990000>n</FONT></FONT></B>:&nbsp; Un puerto es de modo 
  <STRONG>in</STRONG> si la información correspondiente al mismo, entra a la 
  entidad y se suele usar para relojes, entradas de control (como las típicas 
  load, reset y enable), y para datos de entrada unidireccionales.</FONT></P>
  <P align=left><IMG height=20 alt="item01.gif (370 bytes)" 
  src="Lección 2 Unidades Básicas de Diseño_archivos/item01.gif" 
  width=20></FONT><FONT face="MS Sans Serif" size=3>Modo </FONT><FONT 
  size=3><FONT face="MS Sans Serif"><FONT color=#990000><B><FONT 
  size=3>o</FONT>ut</B></FONT>:&nbsp; Un puerto es de modo <STRONG>out</STRONG> 
  si la información fluye hacia fuera de la entidad. Este modo no permite 
  realimentación ya que al declarar un puerto como <STRONG>out</STRONG> estamos 
  indicando al compilador que el estado lógico en el que se encuentra no es 
  leíble. Esto le da una cierta desventaja pero a cambio consume menos recursos 
  de nuestros dispositivos lógicos programables.</FONT></P></BLOCKQUOTE></FONT>
<BLOCKQUOTE>
  <P align=left><FONT size=3><IMG height=20 alt="item01.gif (370 bytes)" 
  src="Lección 2 Unidades Básicas de Diseño_archivos/item01.gif" 
  width=20></FONT><FONT face="MS Sans Serif" size=3>Modo </FONT><FONT 
  face="MS Sans Serif" color=#990000 size=3><B>buffer</B></FONT><FONT 
  face="MS Sans Serif" size=3>:&nbsp; Es usado para una realimentación interna 
  ,es decir, para usar este puerto como un driver dentro de la entidad. Este 
  modo es similar al modo <STRONG>out</STRONG>, pero además, permite la 
  realimentación y no es bidireccional, y solo puede ser conectado directamente 
  a una señal interna, o a un puerto de modo <STRONG>buffer</STRONG> de otra 
  entidad. Una aplicación muy común de este modo es la de salida de un contador, 
  ya que debemos saber la salida en el momento actual para determinar a salida 
  en el momento siguiente.</FONT></P></BLOCKQUOTE>
<BLOCKQUOTE>
  <P align=left><FONT size=3><IMG height=20 alt="item01.gif (370 bytes)" 
  src="Lección 2 Unidades Básicas de Diseño_archivos/item01.gif" 
  width=20></FONT><FONT face="MS Sans Serif" size=3>Modo </FONT><FONT 
  face="MS Sans Serif" color=#990000 size=3><B>inout</B></FONT><FONT 
  face="MS Sans Serif" size=3>: Es usado para señales bidireccionales, es decir, 
  si necesitamos que por el mismo puerto fluya información tanto hacia dentro 
  como hacia afuera de la entidad. Este modo permite la realimentación interna y 
  puede reemplazar a cualquiera de los modos anteriores, pudiéndose usar este 
  modo para todos los puertos, pero reduciremos la lectura posterior del código 
  por otra persona, y reduciendo los recursos disponibles de la 
  dispositivo.</FONT></P></BLOCKQUOTE><FONT size=3>
<P><A name=tipos></A><FONT face="MS Sans Serif">&nbsp;<A name=3></A>&nbsp;&nbsp; 
Como se ha comentado más arriba, el lenguaje sólo admite cuatro modos para los 
puertos, pero puede haber tantos tipos de señales como queramos, ya que <A 
href="http://det.bp.ehu.es/vhdl/pagina/completo/03.htm#3">los podemos crear 
nosotros mismos</A>. VHDL incorpora varios tipos de forma estándar (por haber 
sido creado así), pudiendo usar otros definidos en <A 
href="http://det.bp.ehu.es/vhdl/pagina/completo/02.htm#7">librerías</A> 
normalizadas, y las creados por el usuario. La norma internacional IEEE 1076/93 
define cuatro tipos nativos para VHDL como son:</FONT></FONT> </P>
<BLOCKQUOTE>
  <P><FONT size=3><IMG height=20 alt="item01.gif (370 bytes)" 
  src="Lección 2 Unidades Básicas de Diseño_archivos/item01.gif" 
  width=20></FONT><FONT face="MS Sans Serif" size=3>Tipo</FONT><FONT 
  face="MS Sans Serif"><B><FONT color=#990000><FONT size=3> </FONT></FONT><FONT 
  color=#990000 size=3>boolean</FONT></B><FONT color=#000000 size=3>: puede 
  tomar dos valores: verdadero/true o falso/false. Un ejemplo típico es la 
  salida de un comparador que da verdadero si los números comparados son iguales 
  y falso si no lo son:</FONT></FONT></P></BLOCKQUOTE>
<TABLE cellSpacing=3 width="100%" bgColor=#ffffff border=0>
  <TBODY>
  <TR>
    <TD width="40%"><FONT face="OCR A Extended" color=#000000 
      size=3>equal:<STRONG>out</STRONG> <STRONG>boolean</STRONG>;</FONT></TD>
    <TD width="60%"><FONT face=Verdana size=2>Sólo puede tomar dos valores: 
      verdadero o falso, y es de salida (darle mas operatividad a la salida de 
      un comparador sería superfluo)</FONT></TD></TR></TBODY></TABLE>
<BLOCKQUOTE><B><FONT color=#990000 size=3>
  <P></FONT></B><FONT size=3><IMG height=20 alt="item01.gif (370 bytes)" 
  src="Lección 2 Unidades Básicas de Diseño_archivos/item01.gif" 
  width=20></FONT><FONT face="MS Sans Serif" size=3>Tipo</FONT><B><FONT 
  face="MS Sans Serif" color=#990000 size=3> bit</FONT></B><FONT 
  face="MS Sans Serif" color=#000000 size=3>: Puede tomar dos valores: 0 ó 1 ( o 
  también "low" o "high", según se prefiera). Es el tipo más usado de los 
  nativos.</FONT></P></BLOCKQUOTE>
<BLOCKQUOTE>
  <P><FONT size=3><IMG height=20 alt="item01.gif (370 bytes)" 
  src="Lección 2 Unidades Básicas de Diseño_archivos/item01.gif" 
  width=20></FONT><FONT face="MS Sans Serif" size=3>Tipo</FONT><B><FONT 
  face="MS Sans Serif" color=#990000 size=3> </FONT><FONT 
  face="MS Sans Serif"><FONT color=#990000 size=3>bit_vector</FONT></B><FONT 
  color=#000000 size=3>: Es un vector de bits. Debemos tener cuidado al definir 
  el peso de los bits que lo integran, ya que según pongamos la palabra 
  reservada <STRONG>downto</STRONG> o <STRONG>to</STRONG> estaremos diciendo que 
  el bit más significativo es el número más alto o el más bajo del vector, 
  respectivamente..</FONT></P></BLOCKQUOTE>
<TABLE cellSpacing=3 width="100%" bgColor=#ffffff border=0>
  <TBODY>
  <TR>
    <TD width="48%"><FONT face="OCR A Extended" color=#000000 size=3>numero : 
      <STRONG>bit_vector</STRONG> (0 <STRONG>to</STRONG> 7);</FONT></TD>
    <TD width="52%"><FONT face=Verdana size=2>&nbsp;En este caso el MSB es 
      numero(0) y numero(7) el LSB</FONT></TD></TR>
  <TR>
    <TD width="48%"><FONT face="OCR A Extended" color=#000000 size=3>numero : 
      <STRONG>bit_vector</STRONG> (7 <STRONG>downto</STRONG> 0);</FONT></TD>
    <TD width="52%"><FONT face=Verdana size=2>&nbsp;En este caso el MSB es 
      numero(7) y numero(0) el LSB</FONT></TD></TR></TBODY></TABLE>
<BLOCKQUOTE><B><FONT color=#990000 size=3>
  <P></FONT></B><FONT face="MS Sans Serif"><FONT size=3><IMG height=20 
  alt="item01.gif (370 bytes)" 
  src="Lección 2 Unidades Básicas de Diseño_archivos/item01.gif" 
  width=20>Tipo</FONT><FONT color=#990000 size=3><B> integer</B></FONT><FONT 
  color=#000000 size=3>: Para manejar números enteros. Hay que advertir que el 
  uso de </FONT></FONT></FONT><FONT face="MS Sans Serif" color=#000000 
  size=3>enteros consume muchos recursos del dipositivo de lógica programable, 
  siempre y cuando sea sintetizable, debido a que está prácticamente creado para 
  la simulación.</FONT><FONT face="MS Sans Serif"></P></BLOCKQUOTE>
<P><FONT face="MS Sans Serif" color=#000000 size=3>&nbsp;&nbsp;&nbsp; Pero ante 
la necesidad de ampliar la operatividad del tipo bit, la norma IEEE 1164, 
definió un nuevo tipo llamado <B>std_logic</B>, <B>std_ulogic</B>, y sus 
derivados tales como <B>std_logic_vector</B> y <B>std_ulogic_vector</B>. Como su 
nombre pretende indicar, es el tipo de tipo lógico estándar, que es el más usado 
en la actualidad, así como en la mayoría de ejemplos de este 
libro.</FONT></P><FONT size=3>
<P><FONT face="MS Sans Serif">&nbsp;&nbsp;&nbsp; Como ejemplo, a continuación se 
incluye la declaración de una entidad correspondiente a un multiplexor de 2x1 de 
cuatro bits, con entrada de habilitación o enable.&nbsp;El multiplexor necesita 
las entradas de información, la señal de&nbsp; selección, la de enable y las 
salidas de información.</FONT></FONT></P>
<TABLE cellSpacing=3 width="100%" bgColor=#ffffff border=0>
  <TBODY>
  <TR>
    <TD width="45%"><FONT face="OCR A Extended" size=3><STRONG>entity</STRONG> 
      multi <STRONG>is</STRONG> <STRONG>port</STRONG> (</FONT></TD>
    <TD width="55%"><FONT face=Verdana color=#000000 size=2>Cabecera ya 
      estudiada arriba, en la que <STRONG>multi</STRONG> es el nombre de la 
      entidad</FONT></TD></TR>
  <TR>
    <TD width="45%"><FONT face="OCR A Extended" size=3>enable: 
      <STRONG>in</STRONG> bit;<BR>selec:&nbsp; <STRONG>in</STRONG> 
      bit;<BR>in1:<STRONG> in</STRONG> <STRONG>bit_vector</STRONG>(3 
      <STRONG>downto</STRONG> 0);<BR>in2:<STRONG> in</STRONG> 
      <STRONG>bit_vector</STRONG>(3 <STRONG>downto</STRONG> 
      0);<BR>out1:<STRONG>out</STRONG> <STRONG>bit_vector</STRONG>(3 
      <STRONG>downto</STRONG> 0)</FONT></TD>
    <TD width="55%">
      <UL>
        <LI><FONT face=Verdana color=#000000 size=2><B>enable</B> es un bit de 
        entrada (suficiente para habilitar o no)</FONT> 
        <LI><FONT face=Verdana color=#000000 size=2><B>selec</B> es otro bit de 
        entrada, que selecciona la entrada <B>in1</B> o <B>in2</B>, ambas de 4 
        bits</FONT> 
        <LI><FONT face=Verdana color=#000000 size=2><B>out1</B> es de salida, 
        que lógicamente, debe ser de la misma longitud que <B>in1</B> e 
        <B>in2</B></FONT> </LI></UL></TD></TR>
  <TR>
    <TD width="45%" height=40><FONT face="OCR A Extended" 
      size=3>);<BR><STRONG>end</STRONG> multi;</FONT></TD>
    <TD width="55%" height=40><FONT face=Verdana color=#000000 size=2>Notesé 
      que el último puerto <B><U>no lleva punto y coma</U></B> al final de la 
      línea. Si lo llevase estaría incorrecto</FONT></TD></TR></TBODY></TABLE>
<P align=left></FONT><A name=ejemplo></A><FONT face="MS Sans Serif" 
size=3>&nbsp;&nbsp;&nbsp; A continuación se muestra otro ejemplo correspondiente 
a la entidad para un comparador:</FONT><FONT face="MS Sans Serif"></P>
<TABLE cellSpacing=3 width="100%" bgColor=#ffffff border=0>
  <TBODY>
  <TR>
    <TD width="45%"><FONT face="OCR A Extended" size=3><STRONG>entity</STRONG> 
      compa <STRONG>is</STRONG> <STRONG>port</STRONG> (</FONT></TD>
    <TD width="55%"><FONT face=Verdana color=#000000 size=2>Cabecera de la 
      entidad, cuyo nombre es <STRONG>compa</STRONG></FONT></TD></TR>
  <TR>
    <TD width="45%"><FONT face="OCR A Extended" size=3>a,b: <STRONG>in 
      bit_vector</STRONG>(3 <STRONG>downto</STRONG> 0);<BR>igual:<STRONG> out 
      bit</STRONG>;</FONT></TD>
    <TD width="55%">
      <UL>
        <LI><FONT face=Verdana color=#000000 size=2><B>a </B>y 
        <STRONG>b</STRONG> son las entradas de cuatro bits</FONT> 
        <LI><FONT face=Verdana color=#000000 size=2><B>igual</B> es la salida de 
        un sólo bit</FONT> </LI></UL></TD></TR>
  <TR>
    <TD width="45%" height=40><FONT face="OCR A Extended" 
      size=3>);<BR><STRONG>end</STRONG> compa;</FONT></TD>
    <TD width="55%" height=40><FONT face=Verdana color=#000000 size=2>Se 
      finaliza la entidad con la palabra clave <STRONG>end</STRONG> y el nombre 
      de la misma (<STRONG>compa</STRONG>).</FONT></TD></TR></TBODY></TABLE>
<P align=left><FONT face="MS Sans Serif" size=3>&nbsp;&nbsp;&nbsp; Debemos 
recordar dos puntos más a la hora de dar el nombre a algún puerto, que se 
tratarán más adelante en el aprtado de objetos:</FONT></P>
<BLOCKQUOTE>
  <P><A name="no validos"></A><FONT face="MS Sans Serif" size=3><IMG height=20 
  alt="item01.gif (370 bytes)" 
  src="Lección 2 Unidades Básicas de Diseño_archivos/item01.gif" width=20>VHDL 
  no distingue las letras mayúsculas de las minúsculas, por lo que un puerto 
  llamado por nosotros "EnTraDA" será equivalente a otro que se llame "ENTRADA" 
  o "entrada".</FONT><FONT size=3> <A 
  href="http://det.bp.ehu.es/vhdl/pagina/completo/06.htm#3"><FONT 
  face="MS Sans Serif">Pulsa aquí para ir a una práctica donde se demuestra 
  esto.</FONT></A></FONT></P>
  <P><FONT face="MS Sans Serif" size=3><IMG height=20 
  alt="item01.gif (370 bytes)" 
  src="Lección 2 Unidades Básicas de Diseño_archivos/item01.gif" width=20>El 
  primer carácter de un puerto sólo puede ser una letra, nunca un número. Así 
  mismo, no pueden contener <A 
  href="http://det.bp.ehu.es/vhdl/pagina/completo/03.htm#4">caracteres 
  especiales</A> como $, %, ^, @, ... y dos caracteres de subrayado 
  seguidos.</FONT></P></BLOCKQUOTE><FONT size=3>
<P><FONT face="MS Sans Serif">&nbsp;&nbsp;&nbsp; Estos dos detalles a tener en 
cuenta surgieron del comité que creó este lenguaje, por lo que no se debe 
considerar como un fallo de nuestra herramienta (WARP2), sino como una 
característica más del lenguaje.</FONT></P></FONT>
<P>&nbsp;</P>
<P>&nbsp;</P>
<TABLE cellSpacing=0 width="100%" border=0>
  <TBODY>
  <TR>
    <TD width="74%"><A name=4></A><FONT face=Tahoma color=#000080 
      size=3><U><BIG>Como se declara una Arquitectura</BIG></U></FONT></TD>
    <TD width="26%">
      <P align=right><A 
      href="http://det.bp.ehu.es/vhdl/pagina/completo/02.htm#top"><IMG height=42 
      alt="Inicio de la página" 
      src="Lección 2 Unidades Básicas de Diseño_archivos/image01.gif" width=59 
      border=0></A></P></TD></TR></TBODY></TABLE>
<P align=left></FONT><FONT face="MS Sans Serif" size=3>&nbsp;&nbsp;&nbsp; La 
arquitectura indica el tipo de procesado que se realiza con la información 
correspondiente a las señales de entrada, (declarados previamente en la entidad) 
para llegar a tener los puertos de salida (también declarados en la entidad). En 
la declaración de arquitecturas es donde reside todo el funcionamiento de un 
circuito, ya que es ahí donde se indica que hacer con cada entrada, para obtener 
la salida. Si la entidad es vista como una "caja negra", para la cual lo único 
importante son las entradas y las salidas, entonces, la arquitectura es el 
conjunto de detalles interiores de la caja negra.</FONT><FONT 
face="MS Sans Serif"></P><FONT size=3>
<P align=left><FONT face="MS Sans Serif">&nbsp;&nbsp;&nbsp; La declaración de 
arquitecturas debe constar de las siguientes partes como mínimo, aunque suelen 
ser más:</FONT></FONT></P>
<TABLE cellSpacing=3 width="100%" bgColor=#ffffff border=0>
  <TBODY>
  <TR>
    <TD width="50%"><FONT face="OCR A Extended" 
      size=3><STRONG>architecture</STRONG> archpro <STRONG>of</STRONG> programa 
      <STRONG>is</STRONG></FONT></TD>
    <TD width="50%"><FONT face=Verdana color=#000000 size=2>&nbsp;Cabecera de 
      la arquitectura. En ésta, <B>archpro</B> es un nombre cualquiera (suele 
      empezar por "arch", aunque no es necesario) y<B> programa</B> es el nombre 
      de una entidad existente en el mismo fichero</FONT></TD></TR>
  <TR>
    <TD width="50%"><FONT face="OCR A Extended" size=3>-- declaración de 
      señales y otros accesorios</FONT></TD>
    <TD width="50%"><FONT face=Verdana color=#000000 
      size=2>&nbsp;Declaraciones de apoyo, que se verán en la página 
      siguiente</FONT></TD></TR>
  <TR>
    <TD width="50%"><FONT face="OCR A Extended" 
      size=3><STRONG>begin</STRONG></FONT></TD>
    <TD width="50%"><FONT face=Verdana color=#000000 size=2>&nbsp;Se da 
      comienzo al programa</FONT></TD></TR>
  <TR>
    <TD width="50%"><FONT face="OCR A Extended" size=3>-- núcleo del 
      programa</FONT></TD>
    <TD width="50%"><FONT face=Verdana color=#000000 size=2>Conjunto de 
      sentencias, bucles, procesos, funciones,... que dan operatividad al 
      programa.</FONT></TD></TR>
  <TR>
    <TD width="50%"><FONT face="OCR A Extended" size=3><STRONG>end</STRONG> 
      archpro;</FONT></TD>
    <TD width="50%"><FONT face=Verdana color=#000000 size=2>Fin del 
      programa</FONT></TD></TR></TBODY></TABLE><FONT size=-1>
<P></FONT><FONT face="MS Sans Serif" size=3>&nbsp;&nbsp;&nbsp; Como podemos 
apreciar, es una estructura muy sencilla, y que guarda alguna relación con Turbo 
Pascal. Las sentencias entre <STRONG>begin</STRONG> y <STRONG>end</STRONG> son 
las que </FONT><FONT size=3>describen el circuito</FONT><FONT 
face="MS Sans Serif" size=3>, y es en lo que se centra tanto este libro 
electrónico como cualquier otro que trate sobre VHDL. A continuación, 
</FONT><FONT size=3>se muestra </FONT><FONT face="MS Sans Serif" size=3>el 
código fuente de un programa en VHDL de un multiplexor (esta es una de las 
múltiples formas de implementar un multiplexor en VHDL), el cual debe ir unido a 
la <A href="http://det.bp.ehu.es/vhdl/pagina/completo/02.htm#ejemplo">entidad 
expuesta en el apartado de la declaración de entidades</A>, ya que una parte sin 
la otra carecen de sentido.</FONT></P>
<TABLE cellSpacing=3 width="100%" bgColor=#ffffff border=0>
  <TBODY>
  <TR>
    <TD width="50%" height=81><FONT face="OCR A Extended" 
      size=3><STRONG>architecture</STRONG> archimulti <STRONG>of</STRONG> multi 
      <STRONG>is</STRONG></FONT></TD>
    <TD width="50%" height=81><FONT face=Verdana color=#000000 
      size=2>&nbsp;Cabecera de la arquitectura. En esta ocasión el nombre de la 
      arquitectura es <B>archimulti</B>, y el de la entidad es <B>multi</B>, la 
      cual está definida anteriormente.</FONT></TD></TR>
  <TR>
    <TD width="50%"><FONT face="OCR A Extended" size=3>-- señales</FONT></TD>
    <TD width="50%"></FONT><FONT face="MS Sans Serif" color=#000000 
      size=2>&nbsp;En este programa no </FONT><FONT face=Verdana color=#000000 
      size=2>se necesitan señales</FONT></TD></TR>
  <TR>
    <TD width="50%"><STRONG><FONT face="OCR A Extended" 
      size=3>begin</FONT></STRONG></TD>
    <TD width="50%"><FONT face=Verdana color=#000000 size=2>Comienza al 
      programa</FONT></TD></TR>
  <TR>
    <TD width="50%"><FONT face="OCR A Extended" 
      size=3><STRONG>process</STRONG>(enable,in1,in2)<BR><STRONG>begin</STRONG><BR><STRONG>&nbsp; 
      if</STRONG> enable='0' <STRONG>then</STRONG> 
      out1&lt;="1111";<BR><STRONG>&nbsp; elsif</STRONG> enable='1' 
      <STRONG>then</STRONG><BR><STRONG>&nbsp;&nbsp; if</STRONG>(selec = '0') 
      <STRONG>then</STRONG> out1&lt;=in1;<BR><STRONG>&nbsp;&nbsp; 
      elsif</STRONG>(selec = '1') 
      <STRONG>then</STRONG><BR>&nbsp;&nbsp;&nbsp;&nbsp; 
      out1&lt;=in2;<BR><STRONG>&nbsp;&nbsp; end</STRONG> 
      <STRONG>if</STRONG>;<BR><STRONG>&nbsp; end</STRONG> 
      <STRONG>if</STRONG>;<BR><STRONG>end</STRONG> 
      <STRONG>process</STRONG>;</FONT></TD>
    <TD width="50%"><FONT face=Verdana color=#000000 size=2>Sentencias que 
      hacen que la entidad definida como multiplexor realice la función propia 
      de su nombre. Solo hay que entender la estructura de las arquitecturas en 
      estos momentos, por lo que este código no debe ser objeto de 
      preocupación.</FONT></TD></TR>
  <TR>
    <TD width="50%"><FONT face="OCR A Extended" size=3><STRONG>end</STRONG> 
      archimulti;</FONT></TD>
    <TD width="50%"><FONT face=Verdana color=#000000 size=2>Fin del 
      programa</FONT></TD></TR></TBODY></TABLE>
<P align=left><A name=5></A><FONT face="MS Sans Serif">&nbsp;&nbsp;&nbsp; Para 
describir una arquitectura podremos usar cuatro estilos, teniendo cada uno, su 
propio nivel de abstracción. Los estilos son:</FONT></P>
<BLOCKQUOTE>
  <P align=left><FONT face="MS Sans Serif" size=3><IMG height=20 
  alt="item01.gif (370 bytes)" 
  src="Lección 2 Unidades Básicas de Diseño_archivos/item01.gif" width=20>Estilo 
  </FONT><FONT face="MS Sans Serif" color=#800000 
  size=3><STRONG>behavioral</STRONG></FONT><FONT face="MS Sans Serif" 
  color=#000000 size=3> o </FONT><FONT face="MS Sans Serif" color=#800000 
  size=3><STRONG>comportamiento</STRONG></FONT><FONT face="MS Sans Serif" 
  color=#000000 size=3>: Este estilo se caracteriza por incluir las sentencias y 
  órdenes típicas de un lenguaje de programación (<A 
  href="http://det.bp.ehu.es/vhdl/pagina/completo/04.htm#4"><STRONG>if</STRONG></A>, 
  <A 
  href="http://det.bp.ehu.es/vhdl/pagina/completo/04.htm#4"><STRONG>then</STRONG></A>, 
  <A 
  href="http://det.bp.ehu.es/vhdl/pagina/completo/04.htm#5"><STRONG>case</STRONG></A>,...), 
  sin importarnos como quedará la distribución de puertas lógicas dentro de la 
  PLD. Es necesario un <A 
  href="http://det.bp.ehu.es/vhdl/pagina/completo/05.htm#1">proceso</A> al ser 
  una estructura <A 
  href="http://det.bp.ehu.es/vhdl/pagina/completo/04.htm#1">secuencial</A>. El 
  siguiente fragmento de código describe un comparador (usando una entidad 
  descrita en este mismo tutorial)escrito con el estilo <STRONG>behavioral 
  </STRONG>o de <STRONG>comportamiento</STRONG>.</FONT><FONT 
  face="MS Sans Serif"></P></BLOCKQUOTE>
<TABLE width="100%" bgColor=#ffffff border=0>
  <TBODY>
  <TR>
    <TD width="51%"><FONT face="OCR A Extended"><STRONG>architecture</STRONG> 
      behavioral <STRONG>of</STRONG> compa 
      <STRONG>is</STRONG><BR><STRONG>begin</STRONG><BR>comp: 
      <STRONG>process</STRONG> (a, b)<BR><STRONG>&nbsp; 
      begin</STRONG><BR><STRONG>&nbsp;&nbsp; if</STRONG> a= b 
      <STRONG>then</STRONG><BR>&nbsp;&nbsp;&nbsp; 
      igual&lt;='1';<BR><STRONG>&nbsp;&nbsp; else</STRONG><BR>&nbsp;&nbsp;&nbsp; 
      igual&lt;='0';<BR><STRONG>&nbsp;&nbsp; end</STRONG> 
      <STRONG>if</STRONG>;<BR><STRONG>&nbsp; end</STRONG> 
      <STRONG>process</STRONG> comp;<BR><STRONG>end</STRONG> 
      <STRONG>behavioral</STRONG>;</FONT></TD>
    <TD width="49%"><SMALL><FONT face=Verdana>Como se puede apreciar en este 
      ejemplo se utilizan los clásicos <A 
      href="http://det.bp.ehu.es/vhdl/pagina/completo/04.htm#4"><STRONG>if then 
      else</STRONG></A> de cualquier lenguaje de programación, y además las 
      asignaciones son <A 
      href="http://det.bp.ehu.es/vhdl/pagina/completo/04.htm#1">secuenciales</A>. 
      Esto es lo que hace esta arquitectura de <STRONG>comportamiento</STRONG> o 
      <STRONG>behavioral</STRONG>.</FONT></SMALL></TD></TR></TBODY></TABLE>
<BLOCKQUOTE>
  <P align=left><FONT face="MS Sans Serif" size=3><IMG height=20 
  alt="item01.gif (370 bytes)" 
  src="Lección 2 Unidades Básicas de Diseño_archivos/item01.gif" width=20>Estilo 
  </FONT><FONT face="MS Sans Serif" color=#800000 
  size=3><STRONG>dataflow</STRONG></FONT><FONT face="MS Sans Serif" 
  color=#000000 size=3> o </FONT><FONT face="MS Sans Serif" color=#800000 
  size=3><STRONG>flujo de datos</STRONG></FONT></FONT><FONT face="MS Sans Serif" 
  color=#000000 size=3>: Este estilo podremos encontrarlo de dos formas 
  similares, pero ambas implican cómo la información será transferida de señal a 
  señal y de la entrada a la salida sin el uso de asignaciones secuenciales, 
  sino <A 
  href="http://det.bp.ehu.es/vhdl/pagina/completo/05.htm#1">concurrentes</A>. Es 
  decir, en este estilo no se pueden usar los <A 
  href="http://det.bp.ehu.es/vhdl/pagina/completo/05.htm#1">procesos</A>. El 
  comparador descrito de forma <STRONG>behavioral</STRONG> o de 
  <STRONG>comportamiento</STRONG> se puede escribir usando el estilo 
  <STRONG>dataflow</STRONG> de cualquiera de las dos formas 
  siguientes:</FONT><FONT face="MS Sans Serif"></P></BLOCKQUOTE>
<TABLE width="100%" bgColor=#ffffff border=0>
  <TBODY>
  <TR>
    <TD width="51%"><FONT face="OCR A Extended"><STRONG>architecture</STRONG> 
      dataflow1 <STRONG>of</STRONG> compa 
      <STRONG>is</STRONG><BR><STRONG>begin</STRONG><BR>&nbsp;&nbsp; 
      igual&lt;='1' <STRONG>when</STRONG> (a=b) <STRONG>else</STRONG> 
      '0';<BR><STRONG>end</STRONG> dataflow1;</FONT></TD>
    <TD width="49%"><SMALL><FONT face=Verdana>Esta arquitectura es del estilo 
      dataflow porque se especifica como la información pasará a la salida sin 
      usar sentencias secuenciales</FONT></SMALL></TD></TR></TBODY></TABLE>
<TABLE width="100%" bgColor=#ffffff border=0>
  <TBODY>
  <TR>
    <TD width="51%"><FONT face="OCR A Extended"><STRONG>architecture</STRONG> 
      dataflow2 <STRONG>of</STRONG> compa 
      <STRONG>is</STRONG><BR><STRONG>begin</STRONG><BR>&nbsp;&nbsp; 
      igual&lt;=<STRONG> not</STRONG>(a(0)<STRONG> xor</STRONG> 
      b(0))<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <STRONG>and</STRONG> 
      <STRONG>not</STRONG>(a(1) <STRONG>xor</STRONG> 
      b(1))<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <STRONG>and</STRONG> 
      <STRONG>not</STRONG>(a(2) <STRONG>xor</STRONG> 
      b(2))<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <STRONG>and</STRONG> 
      <STRONG>not</STRONG>(a(3) <STRONG>xor</STRONG> 
      b(3));<BR><STRONG>end</STRONG> dataflow2;</FONT></TD>
    <TD width="49%"><SMALL><FONT face=Verdana>Aquí de nuevo las asignaciones 
      son concurrentes, no secuenciales.</FONT></SMALL></TD></TR></TBODY></TABLE>
<BLOCKQUOTE>
  <P align=left><FONT face="MS Sans Serif" size=3><IMG height=20 
  alt="item01.gif (370 bytes)" 
  src="Lección 2 Unidades Básicas de Diseño_archivos/item01.gif" width=20>Estilo 
  </FONT><FONT face="MS Sans Serif" color=#800000 
  size=3><STRONG>structural</STRONG></FONT><FONT face="MS Sans Serif" 
  color=#000000 size=3> o </FONT><FONT face="MS Sans Serif" color=#800000 
  size=3><STRONG>estructural</STRONG></FONT></FONT><FONT face="MS Sans Serif" 
  color=#000000 size=3>: En él se describe un "netlist" de VHDL, en los cuales 
  los <A 
  href="http://det.bp.ehu.es/vhdl/pagina/completo/02.htm#6">componentes</A> son 
  conectados y evaluados instantáneamente mediante señales. No se suele usar 
  este estilo únicamente en una arquitectura ya que resulta muy lioso y difícil 
  de modificar, siendo de verdadera utilidad cuando debemos crear una estructura 
  grande y deseamos descomponerla en partes para manejarla mejor, y para hacer 
  la simulación de cada parte más sencilla. Se suele requerir el uso de señales 
  auxiliares, y además <A 
  href="http://det.bp.ehu.es/vhdl/pagina/completo/02.htm#6">paquetes</A> y <A 
  href="http://det.bp.ehu.es/vhdl/pagina/completo/02.htm#7">librerías</A> 
  accesorios, lo cual, recordemos, debe estar declarado al comienzo de la <A 
  href="http://det.bp.ehu.es/vhdl/pagina/completo/02.htm#1">entidad</A>.</FONT><FONT 
  face="MS Sans Serif"></P></BLOCKQUOTE>
<TABLE width="100%" bgColor=#ffffff border=0>
  <TBODY>
  <TR>
    <TD width="65%"><FONT face="OCR A Extended"><STRONG>architecture</STRONG> 
      struct <STRONG>of</STRONG> compa 
      <STRONG>is</STRONG><BR><STRONG>signal</STRONG> x: bit_vector(0 to 
      3);<BR><STRONG>begin</STRONG><BR>u0: xnor2 <STRONG>port</STRONG> 
      <STRONG>map</STRONG> (a(0),b(0),x(0));<BR>u1: xnor2 <STRONG>port</STRONG> 
      <STRONG>map</STRONG> (a(1),b(1),x(1));<BR>u2: xnor2 <STRONG>port</STRONG> 
      <STRONG>map</STRONG> (a(2),b(2),x(2));<BR>u3: xnor2 <STRONG>port</STRONG> 
      <STRONG>map</STRONG> (a(3),b(3),x(3));<BR>u4: and4<STRONG> port</STRONG> 
      <STRONG>map</STRONG> (x(0),x(1),x(2),x(3),igual);<BR><STRONG>end</STRONG> 
      struct;</FONT></TD>
    <TD width="35%"><SMALL><FONT face=Verdana>Aquí solo se interconexionan 
      salidas con entradas de componentes. La salida viene dada por la 
      operatividad de los componentes, la cual no se puede saber si no conocemos 
      el paquete del cual ha sido leída.</FONT></SMALL></TD></TR></TBODY></TABLE>
<BLOCKQUOTE>
  <P align=left><FONT face="MS Sans Serif" size=3><IMG height=20 
  alt="item01.gif (370 bytes)" 
  src="Lección 2 Unidades Básicas de Diseño_archivos/item01.gif" width=20>Estilo 
  </FONT><FONT face="MS Sans Serif" color=#800000 
  size=3><STRONG>mixto</STRONG></FONT><FONT face="MS Sans Serif" color=#000000 
  size=3>: Es el estilo que está compuesto en mayor o menor medida de dos o más 
  de los estilos descritos anteriormente.</FONT></P></BLOCKQUOTE>
<P align=left></FONT><FONT face="MS Sans Serif" color=#000000 
size=3>&nbsp;&nbsp;&nbsp; Deberemos tener en cuenta que el código VHDL que 
escribamos no siempre va a describir una función de forma óptima, la cual no 
siempre va a poder ser reducida por la herramienta de compilación. Esto se 
traduce en un peor aprovechamiento de los recursos de las <A 
href="http://det.bp.ehu.es/vhdl/pagina/completo/01.htm#3">PLD's</A>. Por lo 
tanto, diferentes diseños producen diferentes, aunque equivalentes, ecuaciones 
de diseño, pudiéndose dar, sin embargo, disposiciones diferentes de los 
recursos.</FONT><FONT face="MS Sans Serif"></P>
<P align=left></FONT><FONT face="MS Sans Serif" color=#000000 
size=3>&nbsp;&nbsp;&nbsp; Es habitual el usar el estilo estructural para 
descomponer un diseño en unidades manejables,siendo cada unidad diseñada por 
equipos de trabajo distintos. El estilo estructural se usa además para tener un 
grado de control alto sobre la síntesis.</FONT><FONT face="MS Sans Serif"></P>
<P align=left></FONT><FONT face="MS Sans Serif" color=#000000 
size=3>&nbsp;&nbsp;&nbsp; Para concluir el apartado dedicado a las arquitecturas 
sólo resta el recordar que tanto la entidad y la arquitectura deben ir unidas en 
el mismo fichero, ya que una parte carece de sentido sin la otra.</FONT><FONT 
face="MS Sans Serif"><FONT color=#000000><FONT size=3> <A 
href="http://det.bp.ehu.es/vhdl/pagina/completo/06.htm#2">Pulsa aquí para ver el 
proceso a seguir en la compilación.</A></FONT></FONT></P>
<P align=left>&nbsp;</P>
<P align=left>&nbsp;</P>
<TABLE cellSpacing=0 width="100%" border=0>
  <TBODY>
  <TR>
    <TD width="74%"><A name=6></A><FONT face=Tahoma 
      color=#000080><U><BIG>Paquetes</BIG></U></FONT></TD>
    <TD width="26%">
      <P align=right><A 
      href="http://det.bp.ehu.es/vhdl/pagina/completo/02.htm#top"><IMG height=42 
      alt="Inicio de la página" 
      src="Lección 2 Unidades Básicas de Diseño_archivos/image01.gif" width=59 
      border=0></A></P></TD></TR></TBODY></TABLE>
<P><FONT face="MS Sans Serif">&nbsp;&nbsp;&nbsp; Un diseñador de Hardware que 
utilice frecuentemente la misma tecnología de diseño ha de hacerse, con el paso 
del tiempo, con una reseña amplia de procedures, funciones, puertas y, en 
general, de componentes que empleará con frecuencia. Los 
<STRONG>packages</STRONG>&nbsp; permiten agrupar un conjunto de declaraciones 
para que puedan ser usadas en el diseño de diferentes circuitos sin ser 
repetidas en la declaración de cada uno.</FONT></P>
<P><FONT face="MS Sans Serif">&nbsp;&nbsp;&nbsp; La estructura básica en la 
declaración de un paquete está dividida en dos partes claramente diferenciadas: 
</FONT></P>
<BLOCKQUOTE>
  <P><FONT face="MS Sans Serif" size=3><IMG height=20 
  alt="item01.gif (370 bytes)" 
  src="Lección 2 Unidades Básicas de Diseño_archivos/item01.gif" 
  width=20></FONT><FONT face="MS Sans Serif">La declaración del paquete, 
  <STRONG><FONT color=#800000>package</FONT></STRONG>: donde obtenemos una 
  visión externa y simplificada del componente. La declaración del paquete va 
  precedida por la palabra reservada <STRONG>package</STRONG> y finaliza con 
  <STRONG>end</STRONG>. En el cuerpo de la declaración nos encontramos con 
  procedures, funciones, componentes, etc. tal y como aparecerían en la parte de 
  la declaración de una entidad.</FONT></P></BLOCKQUOTE>
<DIV align=center>
<CENTER>
<TABLE width="100%" bgColor=#ffffff border=0>
  <TBODY>
  <TR>
    <TD align=left width="47%">
      <P align=left><FONT face="OCR A Extended"><STRONG>package</STRONG> 
      nombre_del_package <STRONG>is</STRONG> </FONT></P>
      <P align=left><FONT face="OCR A Extended">-- declaración de 
      procedures<BR>-- declaración de funciones<BR>-- declaración de tipos, 
      etc...</FONT></P>
      <P align=left><FONT face="OCR A Extended"><STRONG>end</STRONG> 
      nombre_del_package;</FONT></P></TD>
    <TD align=left width="53%"><SMALL><FONT face=Verdana>Esta parte es a una 
      entidad, lo mismo que un paquete es a un programa normal en 
      VHDL.</FONT></SMALL></TD></TR></TBODY></TABLE></CENTER></DIV>
<BLOCKQUOTE>
  <P><FONT size=2><IMG height=20 alt="item01.gif (370 bytes)" 
  src="Lección 2 Unidades Básicas de Diseño_archivos/item01.gif" 
  width=20></FONT>La declaración del cuerpo del paquete, <FONT 
  color=#800000><STRONG>package body</STRONG></FONT>: especifica el 
  funcionamiento de procedures, funciones, tipos, etc. que nos permite su 
  implementación, de forma similar a la arquitectura. Debe llevar las palabras 
  reservadas <STRONG>package body</STRONG>.</P></BLOCKQUOTE>
<TABLE width="100%" bgColor=#ffffff border=0>
  <TBODY>
  <TR>
    <TD align=left width="48%">
      <P align=left><FONT face="OCR A Extended"><STRONG>package body</STRONG> 
      nombre_del_package <STRONG>is</STRONG></FONT></P>
      <P align=left><FONT face="OCR A Extended">-- definición de 
      procedures<BR>-- definición de funciones<BR>-- definición de tipos, 
      etc.</FONT></P>
      <P align=left><FONT face="OCR A Extended"><STRONG>end</STRONG> 
      nombre_del_package;</FONT></P></TD>
    <TD align=left width="52%"><SMALL><FONT face=Verdana>Esta parte se 
      corresponde con una arquitectura.</FONT></SMALL></TD></TR></TBODY></TABLE>
<P><FONT face="MS Sans Serif">&nbsp;&nbsp;&nbsp; Todo esto hace posible que una 
vez declarados los subprogramas dentro de un package, podamos utilizarlos 
haciendo únicamente uso de una llamada al proceso, asignándole un nombre y la 
lista de parámetros necesarios.</FONT></P>
<P><FONT face="MS Sans Serif">&nbsp;&nbsp;&nbsp; Para poder usar o llamar a un 
package que ha sido descrito anteriormente, debemos incluir la cláusula 
<STRONG>use </STRONG>antes del cuerpo de la arquitectura.</FONT></P>
<TABLE width="100%" bgColor=#ffffff border=0>
  <TBODY>
  <TR>
    <TD width="100%"><FONT face="OCR A Extended"><STRONG>use</STRONG> 
      <STRONG>work</STRONG>.nombre del package.nombre del 
  componente;</FONT></TD></TR></TBODY></TABLE>
<P align=left><FONT face="MS Sans Serif">&nbsp;&nbsp;&nbsp; Para esto se deben 
especificar tres cosas:</FONT></P>
<BLOCKQUOTE>
  <P align=left><FONT face="MS Sans Serif"><FONT size=2><IMG height=20 
  alt="item01.gif (370 bytes)" 
  src="Lección 2 Unidades Básicas de Diseño_archivos/item01.gif" 
  width=20></FONT>El nombre de la librería donde se encuentra el 
  paquete</FONT></P></BLOCKQUOTE>
<BLOCKQUOTE>
  <P align=left><FONT face="MS Sans Serif"><FONT size=2><IMG height=20 
  alt="item01.gif (370 bytes)" 
  src="Lección 2 Unidades Básicas de Diseño_archivos/item01.gif" 
  width=20></FONT>El nombre del paquete</FONT></P>
  <P align=left><FONT face="MS Sans Serif"><FONT size=2><IMG height=20 
  alt="item01.gif (370 bytes)" 
  src="Lección 2 Unidades Básicas de Diseño_archivos/item01.gif" 
  width=20></FONT>El nombre del componente que se desee 
habilitar</FONT></P></BLOCKQUOTE>
<P align=left><FONT face="MS Sans Serif">&nbsp;&nbsp;&nbsp; Hay ocasiones en las 
que deseamos habilitar todos los componentes declarados en un paquete, ya sea 
por comodidad o por no saber exactamente donde se encuentra el recurso que 
deseamos usar. En tal caso, haríamos uso de la palabra <STRONG>all</STRONG> de 
la siguiente forma:</FONT></P>
<TABLE width="100%" bgColor=#ffffff border=0>
  <TBODY>
  <TR>
    <TD width="100%">
      <P align=left><FONT face="OCR A Extended"><STRONG>use</STRONG> 
      <STRONG>work</STRONG>.nombre del 
    package.<STRONG>all;</STRONG></FONT></P></TD></TR></TBODY></TABLE>
<P align=left><FONT face="MS Sans Serif">&nbsp;&nbsp;&nbsp; Como ejemplo se 
muestra a continuación la declaración de un package que contiene a dos 
componente, un contador y un decodificador.</FONT></P>
<TABLE width="100%" bgColor=#ffffff border=0>
  <TBODY>
  <TR>
    <TD width="100%">
      <P align=left></FONT><FONT face="OCR A Extended" 
      size=3><STRONG>--</STRONG>Primero se declaran las librerías que se van a 
      emplear<STRONG><BR>library</STRONG> ieee;<BR><STRONG>use</STRONG> 
      ieee.std_logic_1164.<STRONG>all;</STRONG><BR><STRONG>use</STRONG> 
      <STRONG>work</STRONG>.std_arith.<STRONG>all</STRONG>;<BR>--Empieza la 
      declaración del package "UNO"<BR><STRONG>package</STRONG> uno 
      <STRONG>is</STRONG><BR><STRONG>component</STRONG> <BR>count 
      <STRONG>port</STRONG> (<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      clk,reset:<STRONG>in</STRONG> 
      <STRONG>bit</STRONG>;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      conta&nbsp;&nbsp;&nbsp; :<STRONG>buffer</STRONG> std_logic_vector(1 
      <STRONG>downto</STRONG> 0));<BR>&nbsp;&nbsp;&nbsp; <STRONG>end</STRONG> 
      component;<BR><STRONG>component</STRONG><BR>&nbsp;&nbsp;&nbsp; decoder 
      <STRONG>port</STRONG> (<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      seleccion&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :<STRONG>in</STRONG> 
      std_logic_vector(1 <STRONG>downto</STRONG> 
      0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      enable1,enable2:<STRONG>in</STRONG> 
      <STRONG>bit</STRONG>;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; salida 
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      :<STRONG>out</STRONG> std_logic_vector(3 <STRONG>downto</STRONG> 
      0));<BR>&nbsp;&nbsp;&nbsp; <STRONG>end</STRONG> 
      component;<BR><STRONG>end</STRONG> 
      <STRONG>package</STRONG>;<BR><BR><BR>--Declaración de las 
      estidades<BR><STRONG>library</STRONG> ieee;<BR><STRONG>use</STRONG> 
      ieee.std_logic_1164.<STRONG>all</STRONG>;<BR><STRONG>use</STRONG> 
      work.std_arith.<STRONG>all</STRONG>;<BR><STRONG>use</STRONG> 
      work.uno.<STRONG>all</STRONG>;<BR><STRONG>entity</STRONG> count 
      <STRONG>is</STRONG> <STRONG>port</STRONG> 
      (<BR>clk,reset:<STRONG>in</STRONG> bit;<BR>conta:<STRONG>buffer</STRONG> 
      std_logic_vector(1 <STRONG>downto</STRONG> 0));<BR><STRONG>end</STRONG> 
      count;<BR><BR><STRONG>architecture</STRONG> archicount <STRONG>of</STRONG> 
      count <STRONG>is</STRONG><BR><STRONG>begin</STRONG><BR>contador 
      :<STRONG>process</STRONG> (clk,reset)<BR>&nbsp;&nbsp;&nbsp; 
      <STRONG>begin</STRONG><BR>&nbsp;&nbsp;&nbsp; <STRONG>if</STRONG> 
      (reset='1') <STRONG>then</STRONG> conta &lt;= (others =&gt; '0') 
      ;<BR>&nbsp;&nbsp;&nbsp; <STRONG>elsif</STRONG> clk'<STRONG>event</STRONG> 
      <STRONG>and</STRONG> clk='1' <STRONG>then</STRONG> conta &lt;= conta + 
      1;<BR>&nbsp;&nbsp;&nbsp; <STRONG>end</STRONG> 
      <STRONG>if</STRONG>;<BR>&nbsp;&nbsp;&nbsp; end <STRONG>process</STRONG> 
      contador;<BR><STRONG>end</STRONG> archicount;<BR>--Declaración de las 
      arquitecturas<BR>--Descripcion del decodificador 3/8 
      (74ls138)<BR><STRONG>library</STRONG> ieee;<BR><STRONG>use</STRONG> 
      ieee.std_logic_1164.<STRONG>all</STRONG>;<BR><STRONG>use</STRONG> 
      <STRONG>work</STRONG>.uno.<STRONG>all</STRONG>;<BR><STRONG>entity</STRONG> 
      decoder <STRONG>is port</STRONG> 
      (<BR>seleccion&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :<STRONG>in</STRONG> 
      std_logic_vector(1 <STRONG>downto</STRONG> 
      0);<BR>enable1,enable2:<STRONG>in</STRONG> 
      bit;<BR>salida&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      :<STRONG>out</STRONG> std_logic_vector(3 <STRONG>downto</STRONG> 
      0));<BR><STRONG>end</STRONG> decoder;<BR><BR>--Descripción del 
      decodificador<BR><STRONG>architecture</STRONG> archidecoder 
      <STRONG>of</STRONG> decoder 
      <STRONG>is</STRONG><BR><STRONG>begin</STRONG><BR>decodificador:<STRONG>process</STRONG>(seleccion,enable1,enable2)<BR><STRONG>begin</STRONG><BR><STRONG>if</STRONG> 
      enable2='1' <STRONG>then</STRONG> 
      salida&lt;=(<STRONG>others</STRONG>=&gt;'0');<BR><STRONG>elsif</STRONG> 
      enable2='0' <STRONG>and</STRONG> enable1='0' <STRONG>then</STRONG> 
      salida&lt;=(<STRONG>others</STRONG> =&gt; 
      '0');<BR><STRONG>elsif</STRONG>(enable1='1') <STRONG>then</STRONG> 
      <BR><STRONG>case</STRONG> seleccion 
      <STRONG>is</STRONG><BR>&nbsp;&nbsp;&nbsp; <STRONG>when</STRONG> "00" =&gt; 
      salida &lt;= "0001";<BR>&nbsp;&nbsp;&nbsp; <STRONG>when</STRONG> "01" 
      =&gt; salida &lt;= "0010";<BR>&nbsp;&nbsp;&nbsp; <STRONG>when</STRONG> 
      "10" =&gt; salida &lt;= "0100";<BR>&nbsp;&nbsp;&nbsp; 
      <STRONG>when</STRONG> "11" =&gt; salida &lt;= 
      "1000";<BR>&nbsp;&nbsp;&nbsp; <STRONG>when</STRONG> 
      <STRONG>others</STRONG> =&gt; salida &lt;="1111";<BR><STRONG>end</STRONG> 
      <STRONG>case</STRONG>;<BR><STRONG>end</STRONG> 
      <STRONG>if</STRONG>;<BR><STRONG>end</STRONG> <STRONG>process</STRONG> 
      decodificador;<BR><STRONG>end</STRONG> 
  archidecoder;</FONT></P></TD></TR></TBODY></TABLE>
<P align=left><FONT face="MS Sans Serif">&nbsp;&nbsp;&nbsp;&nbsp; Para poder 
hacer uso, de cualquier componente de el package "uno" (el decodificador o el 
contador),es necesario que primero se incluya la sentencia:</FONT></P>
<TABLE width="100%" bgColor=#ffffff border=0>
  <TBODY>
  <TR>
    <TD width="100%">
      <P align=left><STRONG>use</STRONG> <STRONG>work</STRONG>.<FONT 
      face="OCR A Extended">uno.<STRONG>all;</STRONG></FONT></P></TD></TR></TBODY></TABLE>
<P align=left><FONT face="MS Sans Serif">&nbsp;</P>
<P align=left>&nbsp;</P>
<TABLE cellSpacing=0 width="100%" border=0>
  <TBODY>
  <TR>
    <TD width="74%"><A name=7></A><U><BIG><FONT face="MS Sans Serif" 
      color=#000080>Librer</FONT><FONT face=Tahoma color=#000080>ía LPM (Library 
      of parametrized modules)</FONT></BIG></U></TD>
    <TD width="26%">
      <P align=right><A 
      href="http://det.bp.ehu.es/vhdl/pagina/completo/02.htm#top"><IMG height=42 
      alt="Inicio de la página" 
      src="Lección 2 Unidades Básicas de Diseño_archivos/image01.gif" width=59 
      border=0></A></P></TD></TR></TBODY></TABLE>
<P align=left>&nbsp;&nbsp;&nbsp; La LPM fue propuesto en 1990 como una extensión 
del estándar Electronic Design Interface Format (EDIF)&nbsp; para permitir al 
diseñador crear un circuito completo con independencia de la arquitectura, 
separando las partes físicas y lógicas del diseño</P>
<P align=left>&nbsp;&nbsp;&nbsp; Cada componente en la librería esta definido 
por unos parámetros, que le permiten al diseñador de hardware representar una 
amplia variedad de variables lógicas, evitando la repetición del trabajo.</P>
<P align=left>&nbsp;&nbsp;&nbsp; Un diseño basado en la utilización de la 
librería LPM (library of parametrized modules) combina simultáneamente, los 
aspectos propios de un diseño en alto nivel, con las mejoras propias de la 
síntesis en bajo nivel. Debido a que los componentes descritos en esta librería 
son&nbsp; aceptados por lo fabricantes, su consumo de los recurso internos viene 
previamente optimizado.</P>
<P align=left>&nbsp;&nbsp;&nbsp;&nbsp; La librería LPM System Library, en la 
cual se nos ofrecen múltiples módulos, ya creados, puede facilitarnos 
enormemente nuestro trabajo, ya que incluye desde el generador de constantes más 
sencillo hasta contadores y multiplicadores con todas las características 
opcionales posibles. La lista de componentes incluida en esta es la 
siguiente:</P>
<DIV align=center>
<CENTER>
<TABLE height=1 width="65%" bgColor=#ffffff border=1>
  <TBODY>
  <TR>
    <TD align=right width="50%" height=28><FONT face=Verdana size=2>Nombre del 
      paquete</FONT></TD>
    <TD width="50%" height=28><SMALL><FONT face=Verdana>Nombre del 
      componente</FONT></SMALL></TD></TR>
  <TR>
    <TD align=right width="50%" height=28><FONT face=Verdana 
      size=2>MCCSTNT</FONT></TD>
    <TD width="50%" height=28><SMALL><FONT face=Verdana>Módulo de 
      constantes</FONT></SMALL></TD></TR>
  <TR>
    <TD align=right width="50%" height=28><SMALL><FONT 
      face=Verdana>MINV</FONT></SMALL></TD>
    <TD width="50%" height=28><SMALL><FONT face=Verdana>Módulo de 
      inversores</FONT></SMALL></TD></TR>
  <TR>
    <TD align=right width="50%" height=28><SMALL><FONT 
      face=Verdana>MAND</FONT></SMALL></TD>
    <TD width="50%" height=28><SMALL><FONT face=Verdana>Módulo de 
      AND's</FONT></SMALL></TD></TR>
  <TR>
    <TD align=right width="50%" height=28><FONT face=Verdana 
      color=#000000><SMALL>MOR</SMALL></FONT></TD>
    <TD width="50%" height=28><SMALL><FONT face=Verdana>Módulo de 
      OR's</FONT></SMALL></TD></TR>
  <TR>
    <TD align=right width="50%" height=29><SMALL><FONT 
      face=Verdana>MXOR</FONT></SMALL></TD>
    <TD width="50%" height=29><SMALL><FONT face=Verdana>Módulo de 
      XOR's</FONT></SMALL></TD></TR>
  <TR>
    <TD align=right width="50%" height=29><FONT face=Verdana 
      color=#000000><SMALL>MBUSTRI</SMALL></FONT></TD>
    <TD width="50%" height=29><SMALL><FONT face=Verdana>Módulo de bus 
      triestado</FONT></SMALL></TD></TR>
  <TR>
    <TD align=right width="50%" height=29><SMALL><FONT 
      face=Verdana>MMUX</FONT></SMALL></TD>
    <TD width="50%" height=29><SMALL><FONT face=Verdana>Módulo de 
      multiplexores</FONT></SMALL></TD></TR>
  <TR>
    <TD align=right width="50%" height=29><SMALL><FONT 
      face=Verdana>MDECODE</FONT></SMALL></TD>
    <TD width="50%" height=29><SMALL><FONT face=Verdana>Módulo de 
      decodificador</FONT></SMALL></TD></TR>
  <TR>
    <TD align=right width="50%" height=29><SMALL><FONT 
      face=Verdana>MADD_SUB</FONT></SMALL></TD>
    <TD width="50%" height=29><SMALL><FONT face=Verdana>Módulo de 
      sumadores/restadores</FONT></SMALL></TD></TR>
  <TR>
    <TD align=right width="50%" height=29><SMALL><FONT 
      face=Verdana>MCOMPARE</FONT></SMALL></TD>
    <TD width="50%" height=29><SMALL><FONT face=Verdana>Módulo de 
      comparadores</FONT></SMALL></TD></TR>
  <TR>
    <TD align=right width="50%" height=29><SMALL><FONT 
      face=Verdana>MMULT</FONT></SMALL></TD>
    <TD width="50%" height=29><SMALL><FONT face=Verdana>Módulo de 
      multiplicadores</FONT></SMALL></TD></TR>
  <TR>
    <TD align=right width="50%" height=29><SMALL><FONT 
      face=Verdana>MCOUNTER</FONT></SMALL></TD>
    <TD width="50%" height=29><SMALL><FONT face=Verdana>Módulo de 
      contadores</FONT></SMALL></TD></TR>
  <TR>
    <TD align=right width="50%" height=29><SMALL><FONT 
      face=Verdana>MLATCH</FONT></SMALL></TD>
    <TD width="50%" height=29><SMALL><FONT face=Verdana>Módulo de 
      latches</FONT></SMALL></TD></TR>
  <TR>
    <TD align=right width="50%" height=29><SMALL><FONT 
      face=Verdana>MFF</FONT></SMALL></TD>
    <TD width="50%" height=29><SMALL><FONT face=Verdana>Módulo de 
      flip-flops</FONT></SMALL></TD></TR>
  <TR>
    <TD align=right width="50%" height=29><SMALL><FONT 
      face=Verdana>MSHFTREG</FONT></SMALL></TD>
    <TD width="50%" height=29><SMALL><FONT face=Verdana>Módulo de 
      registros</FONT></SMALL></TD></TR></TBODY></TABLE></CENTER></DIV>
<P><FONT face="MS Sans Serif">&nbsp;&nbsp;&nbsp; Para usar cualquiera de éstos 
módulos, sólamente deberemos incluir en nuestro fichero de código la siguiente 
línea, encima de la declaración de entidades y de arquitecturas:</FONT></P>
<TABLE width="100%" bgColor=#ffffff border=0>
  <TBODY>
  <TR>
    <TD width="100%"><FONT face="OCR A Extended"><STRONG>use</STRONG> 
      <STRONG>work</STRONG>.lpmpkg.<STRONG>all</STRONG>;</FONT></TD></TR></TBODY></TABLE>
<P><FONT face="MS Sans Serif">&nbsp;&nbsp;&nbsp; Como ejemplo crearemos un 
multiplicador de 4 bits (<STRONG>a</STRONG> y <STRONG>b</STRONG>), cuyo 
resultado, obviamente, debe se de 8 bits (<STRONG>p</STRONG>), y que nos permite 
además sumarle otro número de ocho bits (<STRONG>s</STRONG>) al resultado. Para 
ello deberemos invocar previamente a la librería lpmpkg tal y como habíamos 
dicho:</FONT></P>
<TABLE width="100%" bgColor=#ffffff border=0>
  <TBODY>
  <TR>
    <TD width="43%"><FONT face="OCR A Extended"><STRONG>library</STRONG> 
      <STRONG>ieee</STRONG>;<BR><STRONG>use</STRONG> 
      <STRONG>ieee</STRONG>.std_logic_1164.<STRONG>all</STRONG>;<BR><STRONG>use</STRONG> 
      <STRONG>work</STRONG>.lpmpkg.<STRONG>all</STRONG>;<BR><STRONG>entity</STRONG> 
      multi_lpm <STRONG>is</STRONG> <STRONG>port</STRONG>(<BR>&nbsp; a,b: 
      <STRONG>in</STRONG> std_logic_vector(3 <STRONG>downto</STRONG> 
      0);<BR>&nbsp; s:&nbsp;&nbsp; <STRONG>in</STRONG> std_logic_vector(7 
      <STRONG>downto</STRONG> 0);<BR>&nbsp; p:<STRONG>&nbsp; out</STRONG> 
      std_logic_vector(7 <STRONG>downto</STRONG> 
      0)<BR>);<BR><STRONG>end</STRONG> multi_lpm;<BR><BR><STRONG>use</STRONG> 
      <STRONG>work</STRONG>.lpmpkg.<STRONG>all</STRONG>;<BR><STRONG>architecture</STRONG> 
      archimulti <STRONG>of</STRONG> multi_lpm 
      <STRONG>is</STRONG><BR><STRONG>begin</STRONG><BR>&nbsp; a0: mmult 
      <STRONG>generic</STRONG> 
      <STRONG>map</STRONG>(4,4,8,8)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      <STRONG>port</STRONG> <STRONG>&nbsp;&nbsp; 
      map</STRONG>(a,b,s,p);<BR><STRONG>end</STRONG> archimulti;</FONT></TD>
    <TD width="37%"><FONT face="OCR A Extended">&nbsp;<BR>&nbsp; <BR>Llamamos 
      a <STRONG>lpmpkg</STRONG><BR>&nbsp; <BR>Vamos a multiplicar 
      <STRONG>a</STRONG> y<STRONG> b</STRONG><BR>Y vamos a sumar 
      <STRONG>s</STRONG><BR>El resultado es <STRONG>p</STRONG><BR>&nbsp; 
      <BR>&nbsp; <BR>&nbsp; <BR>Llamamos a <STRONG>lpmpkg</STRONG><BR>&nbsp; 
      <BR>&nbsp; <BR>&nbsp; <BR>Usamos el módulo 
      <STRONG>mmult</STRONG><BR>&nbsp; <BR></FONT></TD></TR></TBODY></TABLE>
<P><FONT face="MS Sans Serif">&nbsp;&nbsp;&nbsp; En este ejemplo hemos hecho uso 
del módulo <STRONG>mmult</STRONG>, el cual nos exige no sólo introducirle las 
señales con las cuales operar (con la sentencia <STRONG>port map</STRONG>) sino 
también su dimensión (sentencia <STRONG>generic map</STRONG>). <A 
href="http://det.bp.ehu.es/vhdl/pagina/express/08.htm#5">Pulsa aquí para ir al 
ejemplo del multiplicador. </A></FONT></P>
<P>&nbsp;&nbsp;&nbsp; Como cada módulo tiene unas especificaciones de entradas, 
salida y dimensiones distintas, tendremos que consultar el manual de la librería 
lpmpkg para conocer que entradas y salidas necesita cada módulo. Podemos acceder 
a esta documentación siguiendo estos pasos:</P>
<BLOCKQUOTE>
  <P><IMG height=20 alt="item01.gif (370 bytes)" 
  src="Lección 2 Unidades Básicas de Diseño_archivos/item01.gif" width=20><FONT 
  face="MS Sans Serif">Conseguir el programa WARP2 Release 4.2, disponible 
  online en la página de <A href="http://www.cypress.com/">Cypress Semiconductor 
  Inc.</A> No es neceasrio si ya está instalado en el subdirectorio c:\warp en 
  el ordenador donde estás leyendo estas líneas. Si no lo tienes, isntalaló en 
  esa dirección.</FONT></P>
  <P><IMG height=20 alt="item01.gif (370 bytes)" 
  src="Lección 2 Unidades Básicas de Diseño_archivos/item01.gif" width=20><FONT 
  face="MS Sans Serif">Descargar el programa gratuito <A target=_blank 
  href="http://www.adobe.com/acrobat">Acrobat Reader </A>y sus plug-ins. 
  </FONT></P>
  <P><IMG height=20 alt="item01.gif (370 bytes)" 
  src="Lección 2 Unidades Básicas de Diseño_archivos/item01.gif" width=20><FONT 
  face="MS Sans Serif"> Una vez realizado estos pasos, aparecerá debajo de estas 
  líneas la documentación sobre la librería lpmpkg, en el capítulo 5 del 
  documento. Si no te aparece puedes bajarlo desde aqui: <A 
  href="ftp://vhdl/warp/doc/refmanl.pdf">refmanl.pdf </A></FONT></P></BLOCKQUOTE>
<P align=center>&nbsp;</P></FONT></FONT></FONT></BODY></HTML>
