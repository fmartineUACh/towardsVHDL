--------------------------------------------------------------------
--
--	LPM_COUNTER Parameterized Megafunction
--
--	Copyright (C) 1991-1997 Altera Corporation
--	Any megafunction design, and related net list (encrypted or decrypted),
--	support information, device programming or simulation file, and any other
--	associated documentation or information provided by Altera or a partner
--	under Altera's Megafunction Partnership Program may be used only to
--	program PLD devices (but not masked PLD devices) from Altera.  Any other
--	use of such megafunction design, net list, support information, device
--	programming or simulation file, or any other related documentation or
--	information is prohibited for any other purpose, including, but not
--	limited to modification, reverse engineering, de-compiling, or use with
--	any other silicon devices, unless such use is explicitly licensed under
--	a separate agreement with Altera or a megafunction partner.  Title to
--	the intellectual property, including patents, copyrights, trademarks,
--	trade secrets, or maskworks, embodied in any such megafunction design,
--	net list, support information, device programming or simulation file, or
--	any other related documentation or information provided by Altera or a
--	megafunction partner, remains with Altera, the megafunction partner, or
--	their respective licensors.  No other licenses, including any licenses
--	needed under any third party's intellectual property, are provided herein.
--
--	Version 2.0
--
--------------------------------------------------------------------

INCLUDE "lpm_constant.inc";
INCLUDE "lpm_decode.inc";
INCLUDE "lpm_add_sub.inc";
INCLUDE "cmpconst.inc";
INCLUDE "lpm_counter.inc";

FUNCTION p8count (clk, clrn, setn, ldn, dnup, gn,
                 h, g, f, e, d, c, b, a)
    RETURNS (qh, qg, qf, qe, qd, qc, qb, qa, cout);

FUNCTION f8count (clk, clrn, setn, ldn, dnup, gn,
                 h, g, f, e, d, c, b, a)
    RETURNS (qh, qg, qf, qe, qd, qc, qb, qa, cout);

PARAMETERS
(
	LPM_WIDTH,
	LPM_DIRECTION = "DEFAULT", -- if DEFAULT, depends on updown pin
	LPM_MODULUS = 0,
	LPM_AVALUE = 0,
	LPM_SVALUE = 0,
	DEVICE_FAMILY,
	CARRY_CHAIN = "IGNORE",
	CARRY_CHAIN_LENGTH = 32,
	NOT_GATE_PUSH_BACK = "OFF"
);

-- Evaluated functions
DEFINE break_chain_here(p) = % When to break carry chains %
	  CEIL(LPM_WIDTH div 2) < CARRY_CHAIN_LENGTH & p == CEIL(LPM_WIDTH div 2)
	# CEIL(LPM_WIDTH div 2) >= CARRY_CHAIN_LENGTH & (p mod (CARRY_CHAIN_LENGTH-2)) == 0;
DEFINE Use_Natural_MODULUS() = % Do we need separate modulus checking logic? %
	  USED(LPM_MODULUS) == 0
	# LPM_WIDTH < 32 & LPM_MODULUS == 2^LPM_WIDTH;
DEFINE Ceil_Log2_Modulus() = % Number of bits needed for this LPM_MODULUS %
	USED(LPM_MODULUS) ?
		(LPM_MODULUS < 0 ? (LPM_MODULUS == 2^31 ? 31 : 32)
							 : CEIL(LOG2(LPM_MODULUS)))
		 : 1;
DEFINE OK_to_use_pcustom() =	% If counter is simple enough, use custom logic for p-term %
	  (DEVICE_FAMILY != "FLEX8000" & DEVICE_FAMILY != "FLEX10K")
	& USED(aconst) == 0 & USED(sconst) == 0
	& USED(aset) == 0 & USED(sset) == 0
	& USED(aload) == 0 & USED(sload) == 0 & USED(data) == 0
	& Use_Natural_MODULUS();
DEFINE OK_to_use_8count() =	% Can we just use 8count? %
	  (DEVICE_FAMILY != "FLEX8000" & DEVICE_FAMILY != "FLEX10K"
		# CARRY_CHAIN == "IGNORE")
	& USED(aconst) == 0 & USED(sconst) == 0 & USED(clk_en) == 0
	& USED(aset) == 0 & USED(sset) == 0 & USED(sclr) == 0
	& Use_Natural_MODULUS();
DEFINE Is_multiple_of_8(a) = (CEIL(a div 8) == FLOOR(a div 8));
% do we need a new level to turn off NOT Gate Push-Back ? %
DEFINE need_not_gate_push_back_off() =	
	  NOT_GATE_PUSH_BACK == "ON"
	& (DEVICE_FAMILY == "FLEX8000" # DEVICE_FAMILY == "FLEX10K")
	& (USED(aconst) # USED(aset));

SUBDESIGN lpm_counter
(
	data[LPM_WIDTH-1..0]		: INPUT = GND;
	clock						: INPUT;
	clk_en						: INPUT = VCC;	-- Clock Enable
	cnt_en						: INPUT = VCC;	-- Count Enable
	updown						: INPUT = VCC;	-- VCC is up
	aclr, aset, aconst, aload	: INPUT = GND;
	sclr, sset, sconst, sload	: INPUT = GND;
	q[LPM_WIDTH-1..0]			: OUTPUT;
	eq[15..0]					: OUTPUT;

-- LPM specification calls for the following, but MAX+PLUS II only implements
-- 16 eq outputs:
--	eq[2^LPM_WIDTH-1..0]		: OUTPUT;

)

VARIABLE

	% if aconst or aset is used in a FLEX 8000 or FLEX 10K device,	%
	% NOT_GATE_PUSH_BACK must be turned off							%
	IF (need_not_gate_push_back_off()) GENERATE
		% New LPM_COUNTER instance %
		c2	: lpm_counter WITH (NOT_GATE_PUSH_BACK="OFF");
	ELSE GENERATE
		% Is this a simple p-term counter? %
		IF (OK_to_use_pcustom()) GENERATE
			IF (LPM_WIDTH > 1) GENERATE
				IF (LPM_DIRECTION != "DOWN") GENERATE
					and_a[LPM_WIDTH-1..1][LPM_WIDTH-2..0]	: node;
				END GENERATE;
				and_b[LPM_WIDTH-1..1][LPM_WIDTH-2..0]	: node;
			END GENERATE;
			% state storage %
			dffs[LPM_WIDTH-1..0]		: DFFE;
		ELSE GENERATE
			% can we use the p-term 8count macrofunction? %
			IF (OK_to_use_8count()) GENERATE
				% feature set is limited to 8count, so use 8count %
				IF (DEVICE_FAMILY == "FLEX8000" # DEVICE_FAMILY == "FLEX10K") GENERATE
					p8c[CEIL(LPM_WIDTH div 8)-1..0]	: f8count;
				ELSE GENERATE
					p8c[CEIL(LPM_WIDTH div 8)-1..0]	: p8count;
				END GENERATE;
			ELSE GENERATE
				% state storage %
				dffs[LPM_WIDTH-1..0]		: DFFE;
				nstate[LPM_WIDTH-1..0]		: NODE;
			
				IF (USED(LPM_AVALUE)) GENERATE
					ac	: lpm_constant with (LPM_WIDTH=LPM_WIDTH, LPM_CVALUE=LPM_AVALUE);
				END GENERATE;
				IF (USED(LPM_SVALUE)) GENERATE
					sc	: lpm_constant with (LPM_WIDTH=LPM_WIDTH, LPM_CVALUE=LPM_SVALUE);
				END GENERATE;
			
				IF ((DEVICE_FAMILY == "FLEX8000" # DEVICE_FAMILY == "FLEX10K")
				  & CARRY_CHAIN != "IGNORE" & CARRY_CHAIN_LENGTH > 3) GENERATE
					carrybit[LPM_WIDTH-1..0]	: CARRY;
				ELSE GENERATE
					% Adder/encoder for next-state logic when count is enabled %
					IF (LPM_DIRECTION == "UP") GENERATE
						add			: lpm_add_sub WITH (LPM_WIDTH=LPM_WIDTH,
														ONE_INPUT_IS_CONSTANT="YES",
														LPM_DIRECTION="ADD");
					ELSE GENERATE
						IF (LPM_DIRECTION == "DOWN") GENERATE
							sub		: lpm_add_sub WITH (LPM_WIDTH=LPM_WIDTH,
														ONE_INPUT_IS_CONSTANT="YES",
														LPM_DIRECTION="SUB");
						ELSE GENERATE -- "DEFAULT", depends on updown port
							add_sub	: lpm_add_sub WITH (LPM_WIDTH=LPM_WIDTH,
														ONE_INPUT_IS_CONSTANT="YES");
						END GENERATE;
					END GENERATE;
				END GENERATE;
			
				% Special modulus checking for binary counter (if needed) %
				IF (LPM_DIRECTION == "UP" # LPM_DIRECTION == "DEFAULT") GENERATE
					upwrap	: NODE;
				END GENERATE;
				IF (LPM_DIRECTION == "DOWN" # LPM_DIRECTION == "DEFAULT") GENERATE
					dnwrap	: NODE;
				END GENERATE;
			END GENERATE;
		END GENERATE;
	
		% Output decoder %
		IF (USED(eq)) GENERATE
			decode	: lpm_decode WITH (LPM_WIDTH=4, LPM_DECODES=16);

		--  MAX+PLUS II only implements 16 eq outputs, so this line is not used:
		--	decode	: lpm_decode WITH (LPM_WIDTH=LPM_WIDTH, LPM_DECODES=2^LPM_WIDTH);
		END GENERATE;
	END GENERATE;

BEGIN

	ASSERT (LPM_WIDTH > 0)
			REPORT "Value of LPM_WIDTH parameter must be greater than 0"
			SEVERITY ERROR
			HELP_ID LPM_COUNTER_WIDTH;

	ASSERT (USED(aconst) == 0 # USED(LPM_AVALUE))
			REPORT "Value of LPM_AVALUE parameter must be assigned if aconst port is used"
			SEVERITY ERROR
			HELP_ID LPM_COUNTER_ACONST;

	ASSERT (USED(aconst) == 0 # LPM_AVALUE < 2^LPM_WIDTH)
			REPORT "Value of LPM_AVALUE parameter must be less than 2^LPM_WIDTH if aconst port is used -- using % instead"
				LPM_AVALUE mod 2^LPM_WIDTH
			SEVERITY WARNING
			HELP_ID LPM_COUNTER_ACONST_BIG;

	ASSERT (USED(aconst) # USED(aset) # USED(LPM_AVALUE) == 0)
			REPORT "Ignored LPM_AVALUE parameter because neither the aconst or aset port is used"
			SEVERITY WARNING
			HELP_ID LPM_COUNTER_AVALUE;

	ASSERT (USED(aconst) == 0 # (USED(aclr) == 0 & USED(aset) == 0))
			REPORT "Can't use aconst port if aclr or aset port is used"
			SEVERITY ERROR
			HELP_ID LPM_COUNTER_ACONFLICT;

	ASSERT (USED(sconst) == 0 # USED(LPM_SVALUE))
			REPORT "Value of LPM_SVALUE parameter must be assigned if sconst port is used"
			SEVERITY ERROR
			HELP_ID LPM_COUNTER_SCONST;

	ASSERT (USED(sconst) == 0 # LPM_SVALUE < 2^LPM_WIDTH)
			REPORT "Value of LPM_SVALUE parameter must be less than 2^LPM_WIDTH if sconst port is used -- using % instead"
				LPM_SVALUE mod 2^LPM_WIDTH
			SEVERITY WARNING
			HELP_ID LPM_COUNTER_SCONST_BIG;

	ASSERT (USED(sconst) # USED(sset) # USED(LPM_SVALUE) == 0)
			REPORT "Ignored LPM_SVALUE parameter because neither the sconst or sset port is used"
			SEVERITY WARNING
			HELP_ID LPM_COUNTER_SVALUE;

	ASSERT (USED(sconst) == 0 # (USED(sclr) == 0 & USED(sset) == 0))
			REPORT "Can't use sconst port if sclr or sset port is used"
			SEVERITY ERROR
			HELP_ID LPM_COUNTER_SCONFLICT;

	ASSERT (USED(LPM_MODULUS) == 0 # LPM_WIDTH > 31 # Ceil_Log2_Modulus() <= LPM_WIDTH)
			REPORT "Value of LPM_MODULUS parameter (%) is too large for a %-bit counter"
				LPM_MODULUS, LPM_WIDTH
			SEVERITY WARNING
			HELP_ID LPM_COUNTER_MODULUS_BIG;

	ASSERT (LPM_DIRECTION == "DEFAULT"
		  # LPM_DIRECTION == "UP"
		  # LPM_DIRECTION == "DOWN")
			REPORT "Illegal value for LPM_DIRECTION parameter (%) -- value must be DEFAULT, UP, or DOWN" 
				LPM_DIRECTION
			SEVERITY ERROR
			HELP_ID LPM_COUNTER_DIRECTION;

	ASSERT (LPM_DIRECTION == "DEFAULT" # USED(updown) == 0)
			REPORT "Can't use LPM_DIRECTION parameter if updown port is used"
			SEVERITY ERROR
			HELP_ID LPM_COUNTER_DIR_CONFLICT;

	ASSERT (CARRY_CHAIN == "IGNORE" # CARRY_CHAIN_LENGTH > 3)
			REPORT "Ignored request for carry chain -- chain length setting is too low (< 4) to create useful carry chains"
			SEVERITY WARNING
			HELP_ID LPM_COUNTER_CARRY_LOW;

	IF (need_not_gate_push_back_off()) GENERATE
		IF (USED(data)) GENERATE
			c2.data[] = data[];
		END GENERATE;
		c2.clock = clock;
		IF (USED(clk_en)) GENERATE
			c2.clk_en = clk_en;
		END GENERATE;
		IF (USED(cnt_en)) GENERATE
			c2.cnt_en = cnt_en;
		END GENERATE;
		IF (USED(updown)) GENERATE
			c2.updown = updown;
		END GENERATE;
		IF (USED(aclr)) GENERATE
			c2.aclr = aclr;
		END GENERATE;
		IF (USED(aset)) GENERATE
			c2.aset = aset;
		END GENERATE;
		IF (USED(aconst)) GENERATE
			c2.aconst = aconst;
		END GENERATE;
		IF (USED(aload)) GENERATE
			c2.aload = aload;
		END GENERATE;
		IF (USED(sclr)) GENERATE
			c2.sclr = sclr;
		END GENERATE;
		IF (USED(sset)) GENERATE
			c2.sset = sset;
		END GENERATE;
		IF (USED(sconst)) GENERATE
			c2.sconst = sconst;
		END GENERATE;
		IF (USED(sload)) GENERATE
			c2.sload = sload;
		END GENERATE;
		IF (USED(q)) GENERATE
			q[] = c2.q[];
		END GENERATE;
		IF (USED(eq)) GENERATE
			eq[] = c2.eq[];
		END GENERATE;

	ELSE GENERATE
		% Simple P-term counter? %
		IF (OK_to_use_pcustom()) GENERATE
			% bit 0 just toggles if count is enabled %
			dffs[0] = dffs[0] XOR (sclr & dffs[0] # !sclr & cnt_en);
			dffs[].clk = clock;
			IF (USED(clk_en)) GENERATE
				dffs[].ena = clk_en;
			END GENERATE;
			IF (USED(aclr)) GENERATE
				dffs[].clrn = !aclr;
			END GENERATE;
			IF (LPM_WIDTH > 1) GENERATE
				% For each bit, get and (and band) of all less significant bits %
				FOR ebit IN 1 TO LPM_WIDTH-1 GENERATE
					IF (LPM_DIRECTION != "DOWN") GENERATE
						and_a[ebit][0] =  dffs[0];
					END GENERATE;
					and_b[ebit][0] = !dffs[0];
					IF (LPM_WIDTH > 2) GENERATE
						FOR eand IN 1 TO LPM_WIDTH-2 GENERATE
							IF (eand < ebit) GENERATE
								IF (LPM_DIRECTION != "DOWN") GENERATE
									and_a[ebit][eand] =  dffs[eand] & and_a[ebit][eand-1];
								END GENERATE;
								and_b[ebit][eand] = !dffs[eand] & and_b[ebit][eand-1];
							ELSE GENERATE
								IF (LPM_DIRECTION != "DOWN") GENERATE
									and_a[ebit][eand] = and_a[ebit][eand-1];
								END GENERATE;
								and_b[ebit][eand] = and_b[ebit][eand-1];
							END GENERATE;
						END GENERATE;
					END GENERATE;
					% and_a[ebit][LPM_WIDTH-2] =  dffs[ebit-1] & ... &  dffs[0] %
					% and_b[ebit][LPM_WIDTH-2] = !dffs[ebit-1] & ... & !dffs[0] %
					IF (LPM_DIRECTION == "DOWN") GENERATE
						dffs[ebit].d = dffs[ebit] XOR (sclr & dffs[ebit]
								# !sclr & cnt_en & and_b[ebit][LPM_WIDTH-2]);
					ELSE GENERATE
						dffs[ebit].d = dffs[ebit] XOR (sclr & dffs[ebit]
								# !sclr & cnt_en &  updown & and_a[ebit][LPM_WIDTH-2]
								# !sclr & cnt_en & !updown & and_b[ebit][LPM_WIDTH-2]);
					END GENERATE;
				END GENERATE;
			END GENERATE;

			% Connect outputs %
			q[] = dffs[].q;
		ELSE GENERATE
			IF (OK_to_use_8count()) GENERATE
				--
				-- wire up 8count macrofunctions
				--
				% data inputs %
				IF (Is_multiple_of_8(LPM_WIDTH)) GENERATE
					p8c[].(h, g, f, e, d, c, b, a) = data[];
				ELSE GENERATE
					p8c[].(h, g, f, e, d, c, b, a) = (0, data[]);
				END GENERATE;
		
				% wire up up/down, clock, clr & load signals %
				IF (LPM_DIRECTION == "DOWN") GENERATE
					p8c[].dnup = VCC;
				ELSE GENERATE
					p8c[].dnup = !updown;
				END GENERATE;
				p8c[].clk = clock;
				p8c[].clrn = !aclr;
				p8c[].setn = !aload # aclr;
				p8c[].ldn = !sload;
		
				% wire up Count Enable signal, with logic for later stages %
				p8c0.gn = !cnt_en;
				IF (LPM_WIDTH > 8) GENERATE
					p8c[CEIL(LPM_WIDTH div 8)-1..1].gn = p8c[CEIL(LPM_WIDTH div 8)-2..0].cout
														 !& cnt_en;
				END GENERATE;
		
				% define outputs %
				IF (Is_multiple_of_8(LPM_WIDTH)) GENERATE
					q[] = p8c[].(qh, qg, qf, qe, qd, qc, qb, qa);
				ELSE GENERATE
					IF (LPM_WIDTH > 8) GENERATE
						q[(FLOOR(LPM_WIDTH div 8)*8)-1..0] = 
							p8c[CEIL(LPM_WIDTH div 8)-2..0].(qh, qg, qf, qe, qd, qc, qb, qa);
					END GENERATE;
		
					% LSB of most significant p8count %
					q[FLOOR(LPM_WIDTH div 8)*8] = p8c[CEIL(LPM_WIDTH div 8)-1].qa;
		
					% LSB+1 of most significant p8count %
					IF (LPM_WIDTH > (FLOOR(LPM_WIDTH div 8)*8)+1) GENERATE
						q[(FLOOR(LPM_WIDTH div 8)*8)+1] = p8c[CEIL(LPM_WIDTH div 8)-1].qb;
					END GENERATE;
		
					% LSB+2 of most significant p8count %
					IF (LPM_WIDTH > (FLOOR(LPM_WIDTH div 8)*8)+2) GENERATE
						q[(FLOOR(LPM_WIDTH div 8)*8)+2] = p8c[CEIL(LPM_WIDTH div 8)-1].qc;
					END GENERATE;
		
					% etc... %
					IF (LPM_WIDTH > (FLOOR(LPM_WIDTH div 8)*8)+3) GENERATE
						q[(FLOOR(LPM_WIDTH div 8)*8)+3] = p8c[CEIL(LPM_WIDTH div 8)-1].qd;
					END GENERATE;
					IF (LPM_WIDTH > (FLOOR(LPM_WIDTH div 8)*8)+4) GENERATE
						q[(FLOOR(LPM_WIDTH div 8)*8)+4] = p8c[CEIL(LPM_WIDTH div 8)-1].qe;
					END GENERATE;
					IF (LPM_WIDTH > (FLOOR(LPM_WIDTH div 8)*8)+5) GENERATE
						q[(FLOOR(LPM_WIDTH div 8)*8)+5] = p8c[CEIL(LPM_WIDTH div 8)-1].qf;
					END GENERATE;
					IF (LPM_WIDTH > (FLOOR(LPM_WIDTH div 8)*8)+6) GENERATE
						q[(FLOOR(LPM_WIDTH div 8)*8)+6] = p8c[CEIL(LPM_WIDTH div 8)-1].qg;
					END GENERATE;
					% LSB+7 of most significant p8count is definitely not used %
				END GENERATE;
			ELSE GENERATE
				% Next-state logic is special for FLEX 8000 and FLEX 10K devices %
				% Otherwise, use an adder feeding DFFs 							 %
		
				% common ports %
				dffs[].ena = clk_en;
				dffs[].clk = clock;
			
				% Asynchronous control logic %
				IF (USED(aconst)) GENERATE
					dffs[].clrn = (!aconst # ac.result[]) & (aconst # !aload # data[]);
					dffs[].prn  = (!aconst # !ac.result[]) & (aconst # !aload # !data[]);
				ELSE GENERATE
					IF (USED(LPM_AVALUE)) GENERATE
						dffs[].clrn = !aclr & (!aset # ac.result[]) & (aset # !aload # data[]);
						dffs[].prn = %aclr #% (!aset # !ac.result[]) & (aset # !aload # !data[]);
					ELSE GENERATE
						IF (USED(aclr) # USED(aload)) GENERATE
							dffs[].clrn = !aclr & (aset # !aload # data[]);
						END GENERATE;
						IF (USED(aset) # USED(aload)) GENERATE
							dffs[].prn = %aclr #% !aset & (!aload # !data[]);
						END GENERATE;
					END GENERATE;
				END GENERATE;
			
				% Special logic for odd MODULUS counters %
				IF (LPM_DIRECTION == "UP" # LPM_DIRECTION == "DEFAULT") GENERATE
					IF (Use_Natural_MODULUS() == 0) GENERATE
						upwrap = cmpconst(dffs[].q) WITH (WIDTH=LPM_WIDTH, CVALUE=LPM_MODULUS-1);
					ELSE GENERATE
						upwrap = GND; -- natural modulus
					END GENERATE;
				END GENERATE;
				IF (LPM_DIRECTION == "DOWN" # LPM_DIRECTION == "DEFAULT") GENERATE
					IF (Use_Natural_MODULUS() == 0) GENERATE
						dnwrap = cmpconst(dffs[].q) WITH (WIDTH=LPM_WIDTH, CVALUE=0);
					ELSE GENERATE
						dnwrap = GND; -- natural modulus
					END GENERATE;
				END GENERATE;
			
				% Synchronous input logic %
				IF (USED(sconst)) GENERATE
					dffs[].d = sconst & sc.result[]
							 # !sconst & (sload & data[]
										 # !sload & (cnt_en & nstate[]
													 # !cnt_en & dffs[].q));
				ELSE GENERATE
					IF (USED(LPM_SVALUE)) GENERATE
						dffs[].d = !sclr & (sset & sc.result[]
											# !sset & ( sload & data[]
														# !sload & (cnt_en & nstate[]
																	# !cnt_en & dffs[].q)));
					ELSE GENERATE
						dffs[].d = !sclr & (sset # ( sload & data[]
													# !sload & (cnt_en & nstate[]
																# !cnt_en & dffs[].q)));
					END GENERATE;
				END GENERATE;
			
				% Define next-state logic (assuming count is enabled) %
				IF ((DEVICE_FAMILY == "FLEX8000" # DEVICE_FAMILY == "FLEX10K")
				  & CARRY_CHAIN != "IGNORE" & CARRY_CHAIN_LENGTH > 3) GENERATE
					% First carry bit is always VCC %
					carrybit[0] = VCC; -- always add/sub 1
					IF (LPM_DIRECTION == "UP") GENERATE
						nstate[] = !upwrap & (carrybit[] $ dffs[].q);
						IF (LPM_WIDTH > 1) GENERATE
							IF (CARRY_CHAIN_LENGTH >= LPM_WIDTH) GENERATE
								carrybit[LPM_WIDTH-1..1] = dffs[LPM_WIDTH-2..0].q & carrybit[LPM_WIDTH-2..0];
							ELSE GENERATE
								FOR ebit IN 1 TO LPM_WIDTH-1 GENERATE
									IF (ebit > 1 & (ebit-1) mod (CARRY_CHAIN_LENGTH-2) == 0) GENERATE
										carrybit[ebit] = LCELL(CARRY(dffs[ebit-1].q & carrybit[ebit-1]));
										ASSERT REPORT "Breaking carry chain at bit %" ebit
											SEVERITY DEBUG;
									ELSE GENERATE
										carrybit[ebit] = dffs[ebit-1].q & carrybit[ebit-1];
									END GENERATE;
								END GENERATE;
							END GENERATE;
						END GENERATE;
					ELSE GENERATE
						IF (LPM_DIRECTION == "DOWN") GENERATE
							IF (Use_Natural_MODULUS() == 0) GENERATE
								nstate[] = !dnwrap & (carrybit[] $ dffs[].q)
											# dnwrap & lpm_constant()
												 WITH (LPM_CVALUE=LPM_MODULUS-1);
							ELSE GENERATE
								nstate[] = (dnwrap # VCC) & (carrybit[] $ dffs[].q);
							END GENERATE;
							IF (LPM_WIDTH > 1) GENERATE
								IF (CARRY_CHAIN_LENGTH >= LPM_WIDTH) GENERATE
									carrybit[LPM_WIDTH-1..1] = !dffs[LPM_WIDTH-2..0].q & carrybit[LPM_WIDTH-2..0];
								ELSE GENERATE
									FOR ebit IN 1 TO LPM_WIDTH-1 GENERATE
										IF (ebit > 1 & (ebit-1) mod (CARRY_CHAIN_LENGTH-2) == 0) GENERATE
											carrybit[ebit] = LCELL(CARRY(!dffs[ebit-1].q & carrybit[ebit-1]));
											ASSERT REPORT "Breaking carry chain at bit %" ebit
												SEVERITY DEBUG;
										ELSE GENERATE
											carrybit[ebit] = !dffs[ebit-1].q & carrybit[ebit-1];
										END GENERATE;
									END GENERATE;
								END GENERATE;
							END GENERATE;
						ELSE GENERATE -- "DEFAULT", depends on updown port
							IF (Use_Natural_MODULUS() == 0) GENERATE
								nstate[] = updown & !upwrap & (carrybit[] $ dffs[].q)
										 # !updown & (!dnwrap & (carrybit[] $ dffs[].q)
													  # dnwrap & lpm_constant()
																 WITH (LPM_CVALUE=LPM_MODULUS-1));
							ELSE GENERATE
								nstate[] = updown & !upwrap & (carrybit[] $ dffs[].q)
										 # !updown & (!dnwrap & (carrybit[] $ dffs[].q));
							END GENERATE;
							IF (LPM_WIDTH > 1) GENERATE
								IF (CARRY_CHAIN_LENGTH >= LPM_WIDTH) GENERATE
									carrybit[LPM_WIDTH-1..1] = (dffs[LPM_WIDTH-2..0].q !$ updown)
																& carrybit[LPM_WIDTH-2..0];
								ELSE GENERATE
									FOR ebit IN 1 TO LPM_WIDTH-1 GENERATE
										IF (break_chain_here(ebit)) GENERATE
											carrybit[ebit] = LCELL(CARRY(
																(dffs[ebit-1].q !$ updown)
																& carrybit[ebit-1]));
											ASSERT REPORT "Breaking carry chain at bit %" ebit
												SEVERITY DEBUG;
										ELSE GENERATE
											carrybit[ebit] = (dffs[ebit-1].q !$ updown)
																& carrybit[ebit-1];
										END GENERATE;
									END GENERATE;
								END GENERATE;
							END GENERATE;
						END GENERATE;
					END GENERATE;
				ELSE GENERATE
					
					% Next state %
					IF (LPM_DIRECTION == "UP") GENERATE
						add.dataa[] = dffs[].q;
						IF (LPM_WIDTH > 1) GENERATE
							add.datab[] = 1;
						ELSE GENERATE
							add.datab[] = VCC;
						END GENERATE;
						nstate[] = !upwrap & add.result[];
					ELSE GENERATE
						IF (LPM_DIRECTION == "DOWN") GENERATE
							sub.dataa[] = dffs[].q;
							IF (LPM_WIDTH > 1) GENERATE
								sub.datab[] = 1;
							ELSE GENERATE
								sub.datab[] = VCC;
							END GENERATE;
							IF (Use_Natural_MODULUS() == 0) GENERATE
								nstate[] = !dnwrap & sub.result[]
										  # dnwrap & lpm_constant()
												 WITH (LPM_CVALUE=LPM_MODULUS-1);
							ELSE GENERATE
								nstate[] = (dnwrap # VCC) & sub.result[];
							END GENERATE;
						ELSE GENERATE -- "DEFAULT", depends on updown port
							add_sub.dataa[] = dffs[].q;
							IF (LPM_WIDTH > 1) GENERATE
								add_sub.datab[] = 1;
							ELSE GENERATE
								add_sub.datab[] = VCC;
							END GENERATE;
							add_sub.add_sub = updown;
							IF (Use_Natural_MODULUS() == 0) GENERATE
								nstate[] = updown & !upwrap & add_sub.result[]
										 # !updown & (!dnwrap & add_sub.result[]
													  # dnwrap & lpm_constant()
																 WITH (LPM_CVALUE=LPM_MODULUS-1));
							ELSE GENERATE
								nstate[] = updown & !upwrap & add_sub.result[]
										 # !updown & (!dnwrap & add_sub.result[]);
							END GENERATE;
						END GENERATE;
					END GENERATE;
				END GENERATE;

				% Connect outputs %
				q[] = dffs[].q;
			END GENERATE;
		END GENERATE;

		% Connect decoder (if outputs are used) %
		IF (USED(eq)) GENERATE
			IF (LPM_WIDTH >= 4) GENERATE
				decode.data[] = q[3..0];
				IF (LPM_WIDTH > 4) GENERATE
					decode.enable = cmpconst(q[LPM_WIDTH-1..4])
										WITH (WIDTH=LPM_WIDTH-4, CVALUE=0);
				END GENERATE;
			ELSE GENERATE
				decode.data[] = (0, q[]);
			END GENERATE;
			eq[] = decode.eq[];
		ELSE GENERATE
			eq[] = GND;
		END GENERATE;
	END GENERATE;
END;
