--------------------------------------------------------------------
--
--	NTSC Waveform Generator
--
--	Copyright (C) 1991-1997 Altera Corporation
--	Any megafunction design, and related net list (encrypted or decrypted),
--	support information, device programming or simulation file, and any other
--	associated documentation or information provided by Altera or a partner
--	under Altera's Megafunction Partnership Program may be used only to
--	program PLD devices (but not masked PLD devices) from Altera.  Any other
--	use of such megafunction design, net list, support information, device
--	programming or simulation file, or any other related documentation or
--	information is prohibited for any other purpose, including, but not
--	limited to modification, reverse engineering, de-compiling, or use with
--	any other silicon devices, unless such use is explicitly licensed under
--	a separate agreement with Altera or a megafunction partner.  Title to
--	the intellectual property, including patents, copyrights, trademarks,
--	trade secrets, or maskworks, embodied in any such megafunction design,
--	net list, support information, device programming or simulation file, or
--	any other related documentation or information provided by Altera or a
--	megafunction partner, remains with Altera, the megafunction partner, or
--	their respective licensors.  No other licenses, including any licenses
--	needed under any third party's intellectual property, are provided herein.
--
--	Version 1.0
--
--------------------------------------------------------------------

TITLE "NTSC Waveform Generator";

%
|	Functional Description
|
|	The NTSC megafunction uses Clock and active-low Reset input signals to
|	generate a digital representation of the NTSC control signals CSYNC, HD, VD,
|	FIELD, BURST, and BLANK. These signals can be used to control video imaging
|	or display equipment.
|
|	To implement a complete NTSC pattern, this megafunction contains a 6-state 
|	state machine with the following states: power-up (POWER_UP), 
|	pre-equalization (PRE_EQ), serration (SERRA), post-equalization (POST_EQ), 
|	sub-phase (SUB_PH), and video-active (VID_ACT). During each of these 
|	distinct states, the outputs are generated according to a different 
|	set of rules, and the state machine controls the output generation.
|
|	Each horizontal line contains 910 pixels. The NTSC megafunction treats each
|	line as a pair of half-lines, so the HCNT_ROLL_OVER signal is set to 453 
|	(one less than the half-line value of 454, which provides 910 pixels when 
|	multiplied by two).
|
|	The constant VCNT_ROLL_OVER is set to 525, representing the 525 lines per 
|	screen specified by the NTSC standard. Each screen contains two frames 
|	that each have 262.5 lines to provide interlacing. Since non-integer 
|	counters are very hard to control, the system counts to 525 half-lines, 
|	then repeats the count sequence for the second frame. The two frames are 
|	offset by one half-line so that a complete picture is formed with the 
|	analog video data from both of the frames.
|
|	For more detailed information on NTSC pattern generation, consult the 
|	NTSC standards or any textbook on video applications.
%

%
|	PATTERN CONSTANTS SECTION
|
|	Constants shown for phase conditions (eg: START_PRE_EQ) are decoded off the
|	vertical counter. State transitions are based on the line that is currently
|	being decoded. The values are shown as binary numbers (denoted by the
|	B"xxxx" format), and represent the Gray-code values that correspond to the
|	decimal values shown in a comment on each line.
|
|	Constants for the J and K inputs (e.g., HD_J) are also Gray-code values, 
|	with the corresponding decimal value shown in a comment. These constants 
|	are compared with the horizontal counter to make pulses in the output 
|	signals.
|
|	The constants with names that begin with "START" are starting points for the
|	correspondingly named NTSC phase. For this model we assume that the NTSC 
|	standard has 5 phases: pre-equalization (PRE_EQ), serration (SERRA), 
|	post-equalization (POST_EQ), sub-phase (SUB_PH), and video-active (VID_ACT).
|	Each phase starts at defined vertical lines, and these are set by the 
|	first 5 constants given below. Since they are decoding a Gray-code 
|	counter, the equivalent decimal value is shown in a comment (e.g., video 
|	active starts on the 20th line in the scan).
%

CONSTANT START_PRE_EQ		= B"0000000000";	% line 0		D"0"		%
CONSTANT START_SERRA		= B"0000000101";	% line 3		D"6"		%
CONSTANT START_POST_EQ		= B"0000001010";	% line 6		D"12"		%
CONSTANT START_SUB_PH		= B"0000011011";	% line 9		D"18"		%
CONSTANT START_VID_ACT		= B"0000111100";	% line 20		D"40"		%

%
|	These constants define the transitions on the various NTSC output signals
|	during the 5 phases of the NTSC standard. In each case, the constant shown
|	represents a value that is compared to the horizontal pixel counter. In the
|	case of the CSYNC signal the output depends on the current phase, so 5 
|	constants are given to completely specify the operation. HD, BLANK, and 
|	BURST behave the same in all 5 states, so only one constant pair is given.
|	Note that a "J" and a "K" constant are always given because the output 
|	pulses on all the output signals must be turned on and then turned 
|	off again at specific horizontal count values. The "J" is routed to the J 
|	input of a JK flipflop that asserts the output when true, and the "K" is
|	routed to the K input to a JK flipflop that deasserts the output
|	when true.
|
|	By setting the value of CSYNC_PRE_EQ_J to the Gray-code equivalent of 
|	decimal 36, the CSYNC signal is asserted at the 36th horizontal bit. 
|	By setting CSYNC_PRE_EQ_K equal to the Gray-code equivalent to decimal 1, 
|	CSYNC is deasserted at the first horizontal bit. During the pre-
|	equalization phase there are 6 "half-lines" (as defined by the constant 
|	START_SERRA being set to the Gray-code equivalent of decimal 6), so the 
|	CSYNC signal will make 6 pulses during pre-equalization phases. For 
|	this reason, the falling edge at the first point in a horizontal scan ends 
|	the high-level signal for the previous line. Since CSYNC is an active-low 
|	signal, this creates a pulse that lasts from the 1st to the 36th
|	bit on the horizontal scan, and then repeats for a total of 6 lines.
|
|	The active-low CSYNC signal behaves as follows during the pre-equalization
|	phase: The first (falling) edge occurs when the horizontal counter is equal
|	to the Gray-code equivalent of "1" and the second (rising) edge occurs when 
|	the horizontal counter is equal to the Gray-code equivalent of "36". Note 
|	that these edges should technically occur at "0" and "35", but to avoid 
|	synchronization problems with the boundary between the two frames in the 
|	interlaced screen format, the transitions are all offset by one.
|
|   1      36                    454/1     36                     454/1
|           ________________|  |____        ________________|  |____  
|   |      |                |  |    |      |                |  |    |  
|   |      |                        |      |                        |
|   |______|                        |______|                        |_ . . 
|
|   {--------  first line  ---------}{--------  second line  -------}
|
|	Counter values are compared to constants in the "WHEN pre_eq" clauses
|	in the state machine Case Statement state transition. Corresponding WHEN 
|	statements are provided for all 5 NTSC phases. Each WHEN clause defines
|	each of the 6 output signals during each of the 5 states.
%

CONSTANT CSYNC_PRE_EQ_J		= B"000110110";		% 				D"36"		%
CONSTANT CSYNC_PRE_EQ_K		= B"000000001";		%				D"1"		%

CONSTANT CSYNC_SERRA_J		= B"101000100";		%				D"391"		%
CONSTANT CSYNC_SERRA_K		= B"000000001";		%				D"1"		%

CONSTANT CSYNC_POST_EQ_J	= B"000110110";		%				D"36"		%
CONSTANT CSYNC_POST_EQ_K	= B"000000001";		%				D"1"		%

CONSTANT CSYNC_SUB_PH_J		= B"001100110";		%				D"68"		%
CONSTANT CSYNC_SUB_PH_K		= B"000000001";		%				D"1"		%

CONSTANT CSYNC_VID_ACT_J	= B"001100110";		%				D"68"		%
CONSTANT CSYNC_VID_ACT_K	= B"000000001";		%		 		D"1"		%

CONSTANT HD_J				= B"001110110";		%				D"91"		%
CONSTANT HD_K				= B"000000001";		%				D"1"		%

CONSTANT BLANK_J			= B"011010111";		%				D"154"		%
CONSTANT BLANK_K			= B"000000001";		%				D"1"		%

CONSTANT BURST_J			= B"001000001";		%				D"126"		%
CONSTANT BURST_K			= B"001101110";		%				D"75"		%

%
|	COUNTER CONSTANTS SECTION
|
|	These constants specify rollover and terminal count values. 453 is the end 
|	of the first half-line. Half-lines are used to accommodate the interlacing 
|	scheme specified by NTSC. Half-lines make it possible to use an integer 
|	value to count the lines per screen. Full lines would make it necessary
|	to count to 262.5 (a half-line) and then switch frames. It is difficult
|	to count in non-integer mode with digital logic.
|
|	The VCNT value of 525 is the end of the first frame in the two-frame 
|	interlaced model. These values can be changed to match other video display 
|	formats. 
%
	
CONSTANT HCNT_ZERO			= B"000000000";		% D"0" for start value		%
CONSTANT HCNT_ROLL_OVER		= B"100100111"; 	% D"453" for hhalf			%
CONSTANT VCNT_ROLL_OVER		= B"1100001010";	% D"525"					%

%
|	No particular device is specified for this megafunction. In its current 
|	form, it uses 31 macrocells in the EPS464 EPLD, and 32 macrocells in the 
|	MAX 5000 and MAX 7000 device families.
%


SUBDESIGN ntsc
	(
	clock				: INPUT = GND;			% System global Clock		%
	reset				: INPUT = VCC;			% System Reset (active low)	%

	csync,										% NTSC output signals		%
	hd,
	vd,			
	fld,										
	blank,
	burst				: OUTPUT;
	)

%
|	line_decode	is a state machine used to control the NTSC waveforms. The
|	outputs csync, hsync, vsync, field_ff, blank, and burst are all created with
|	JK flipflops.
%

VARIABLE

	line_decode :	MACHINE
					OF BITS 	(	q[2..0] )
					WITH STATES	(	_power_up ,
									_pre_eq   ,
									_serra    ,
									_post_eq  ,
									_sub_ph   ,
									_vid_act
								);

	gclk				:	NODE; 				% Global Clock node			%
	grst				:	NODE;				% Global Reset node			%

	csync_ff			:	JKFF;
	hd_ff				:	JKFF;
	vd_ff				:	JKFF;
	fld_ff				:	JKFF;
	blank_ff			:	JKFF;
	burst_ff			:	JKFF;

	pwr_up				:	NODE;
	cnt_reset			:	NODE; 

%
|	Counter variables. Eleven bits for lines per screen (10 in the counter, and
|	line_ff as the terminal bit), and 10 bits for pixels per line (9 in the 
|	counter and h_odd as the terminal bit).
%

	v[9..0]				:	TFF;			% Vertical counter bits			%
	h[8..0]				:	TFF;			% Horizontal counter bits		%
	line_ff				:	TFF;			% First/second halfline_ff		%
	h_odd				:	TFF;			% Odd horizontal bit			%
	field_ff			:	TFF;			% Odd/even field_ff indicator	%	
	vcnt_reset			:	NODE;			% Terminal/reset condition		%
	hcnt_reset			:	NODE;			% Terminal/reset condition		%


BEGIN

	gclk = GLOBAL(clock);
	grst = reset;

%
|	Set up flipflop and state machine Clocks and Clears
%

	line_decode.clk		=	gclk;
	line_decode.reset	=	!grst;

	v[].clk				=	gclk;
	h[].clk				=	gclk;
	h_odd.clk			=	gclk;
	field_ff.clk		=	gclk;
	line_ff.clk			=	gclk;

	vd_ff.clk			=	gclk;
	hd_ff.clk			=	gclk;
	csync_ff.clk		=	gclk;
	fld_ff.clk			=	gclk;
	blank_ff.clk		=	gclk;
	burst_ff.clk		=	gclk;

%
|	Define state transitions
%

	CASE ( line_decode ) IS

		WHEN _power_up	=>
            pwr_up      =	VCC;
            cnt_reset   =	VCC;
            csync_ff.j  =	VCC;
            hd_ff.j     =	VCC;
            vd_ff.k     =	VCC;
            fld_ff.k    =	VCC;
            blank_ff.k  =	VCC;
            burst_ff.j  =	VCC;
            line_decode =	_pre_eq;

		WHEN _pre_eq	=>
			csync_ff.j	=	(h[] == CSYNC_PRE_EQ_J);
			csync_ff.k	=	(h[] == CSYNC_PRE_EQ_K);
			vd_ff.k 	=	VCC;
			hd_ff.j		=	((h[] == HD_J) & !line_ff & !field_ff)
						#	((h[] == HD_J) & !line_ff & field_ff);
			hd_ff.k		=	((h[] == HD_K) & !line_ff & !field_ff)
						#	((h[] == HD_K) & !line_ff & field_ff);
			fld_ff.k	=	VCC;
			blank_ff.k	=	VCC;
			burst_ff.j	=	VCC;
			
			IF (v[] == START_SERRA ) THEN
				line_decode = _serra ;
			END IF;
    
		WHEN _serra		=>
			csync_ff.j	=	(h[] == CSYNC_SERRA_J);
			csync_ff.k	=	(h[] == CSYNC_SERRA_K);
			hd_ff.j		=	((h[] == HD_J) & !line_ff & !field_ff)
						#	((h[] == HD_J) & !line_ff & field_ff);
			hd_ff.k		=	((h[] == HD_K) & !line_ff & !field_ff)
						#	((h[] == HD_K) & !line_ff & field_ff);
			vd_ff.k		=	VCC;
			fld_ff.j	=	VCC;
			blank_ff.k	=	VCC;
			burst_ff.j	=	VCC;
 
			IF (v[] == START_POST_EQ ) THEN
				line_decode = _post_eq ;
			END IF;
   
		WHEN _post_eq	=>
			csync_ff.j	=	h[] == CSYNC_POST_EQ_J;
			csync_ff.k	=	h[] == CSYNC_POST_EQ_K;
            hd_ff.j     =   ((h[] == HD_J) & !line_ff & !field_ff)
                        #   ((h[] == HD_J) & !line_ff & field_ff);
            hd_ff.k     =   ((h[] == HD_K) & !line_ff & !field_ff)
                        #   ((h[] == HD_K) & !line_ff & field_ff);
			vd_ff.k		=	VCC;
			fld_ff.j	=	VCC;
			blank_ff.k	=	VCC;
			burst_ff.j	=	VCC;

			IF (v[] == START_SUB_PH ) THEN
				line_decode = _sub_ph ;
			END IF;

		WHEN _sub_ph	=>
            csync_ff.j  =   ((h[] == CSYNC_SUB_PH_J) & !line_ff & !field_ff)
                        #   ((h[] == CSYNC_SUB_PH_J) & !line_ff & field_ff);
            csync_ff.k  =   ((h[] == CSYNC_SUB_PH_K) & !line_ff & !field_ff) 
                        #   ((h[] == CSYNC_SUB_PH_K) & !line_ff & field_ff);
            hd_ff.j     =   ((h[] == HD_J) & !line_ff & !field_ff)
                        #   ((h[] == HD_J) & !line_ff & field_ff);
            hd_ff.k     =   ((h[] == HD_K) & !line_ff & !field_ff)
                        #   ((h[] == HD_K) & !line_ff & field_ff);
			vd_ff.j		=	VCC;
			fld_ff.j	=	VCC;
            burst_ff.j  =   ((h[] == BURST_J) & !line_ff & !field_ff)
                        #   ((h[] == BURST_J) & !line_ff & field_ff);
            burst_ff.k  =   ((h[] == BURST_K) & !line_ff & !field_ff)
                        #   ((h[] == BURST_K) & !line_ff & field_ff);
			blank_ff.k	=	VCC;

			IF (v[] == START_VID_ACT ) THEN
				line_decode = _vid_act;
			END IF;
  
		WHEN _vid_act	=>
            csync_ff.j  =   ((h[] == CSYNC_VID_ACT_J) & !line_ff & !field_ff)
                        #   ((h[] == CSYNC_VID_ACT_J) & !line_ff & field_ff);
            csync_ff.k  =   ((h[] == CSYNC_VID_ACT_K) & !line_ff & !field_ff) 
                        #   ((h[] == CSYNC_VID_ACT_K) & !line_ff & field_ff);
            hd_ff.j     =   ((h[] == HD_J) & !line_ff & !field_ff)
                        #   ((h[] == HD_J) & !line_ff & field_ff);
            hd_ff.k     =   ((h[] == HD_K) & !line_ff & !field_ff)
                        #   ((h[] == HD_K) & !line_ff & field_ff);
			vd_ff.j		=	VCC;
			fld_ff.j	=	VCC;
            burst_ff.j  =   ((h[] == BURST_J) & !line_ff & !field_ff)
                        #   ((h[] == BURST_J) & !line_ff & field_ff);
            burst_ff.k  =   ((h[] == BURST_K) & !line_ff & !field_ff)
                        #   ((h[] == BURST_K) & !line_ff & field_ff);
            blank_ff.j  =   ((h[] == BLANK_J) & !line_ff & !field_ff)
                        #   ((h[] == BLANK_J) & !line_ff & field_ff);
            blank_ff.k  =   ((h[] == BLANK_K) & !line_ff & !field_ff)
                        #   ((h[] == BLANK_K) & !line_ff & field_ff);
			
			IF (v[] == START_PRE_EQ ) THEN
				line_decode = _pre_eq;
			END IF;

		END CASE;

%
|	Establish the output connections
%

	csync				=	csync_ff;
	hd					=	hd_ff;
	vd					=	vd_ff;
	fld					=	fld_ff;
	burst				=	burst_ff;
	blank				=	blank_ff;

%
|	Equations for line_ff and field_ff. When the horizontal counter is in the 
|	first half of the scan-line, the line_ff output will be low. A high 
|	indicates that the counter is in the second half of the scan-line. To make 
|	an efficient circuit, the vertical counter uses line_ff as the terminal 
|	bit. The field_ff is used to track the current field. During odd fields 
|	(1st physical field), the field_ff output will be low. During even fields 
|	it will be high. 
%

	line_ff				=	(h[] == HCNT_ROLL_OVER);
	field_ff			=	(v[] == VCNT_ROLL_OVER & h[] == HCNT_ROLL_OVER);

%
|	Gray-code equations. Each bit toggles when previous bits are 10..0 and
|	the odd bit is 1.
%
	IF(!field_ff) THEN

	v[] =  (((v[], line_ff)  == B"X1000000001") & !vcnt_reset # vcnt_reset & v9,
			((v[], line_ff)  == B"XX100000001") & !vcnt_reset # vcnt_reset & v8,
			((v[], line_ff)  == B"XXX10000001") & !vcnt_reset # vcnt_reset & v7,
			((v[], line_ff)  == B"XXXX1000001") & !vcnt_reset # vcnt_reset & v6,
			((v[], line_ff)  == B"XXXXX100001") & !vcnt_reset # vcnt_reset & v5,
			((v[], line_ff)  == B"XXXXXX10001") & !vcnt_reset # vcnt_reset & v4,
			((v[], line_ff)  == B"XXXXXXX1001") & !vcnt_reset # vcnt_reset & v3,
			((v[], line_ff)  == B"XXXXXXXX101") & !vcnt_reset # vcnt_reset & v2,
			((v[], line_ff)  == B"XXXXXXXXX11") & !vcnt_reset # vcnt_reset & v1,
			((v[], line_ff)  == B"XXXXXXXXXX0") & !vcnt_reset # vcnt_reset & v0
			)
			& (h[] == HCNT_ROLL_OVER);
	ELSE
	v[] =  (((v[], !line_ff)  == B"X1000000001") & !vcnt_reset # vcnt_reset & v9,
			((v[], !line_ff)  == B"XX100000001") & !vcnt_reset # vcnt_reset & v8,
			((v[], !line_ff)  == B"XXX10000001") & !vcnt_reset # vcnt_reset & v7,
			((v[], !line_ff)  == B"XXXX1000001") & !vcnt_reset # vcnt_reset & v6,
			((v[], !line_ff)  == B"XXXXX100001") & !vcnt_reset # vcnt_reset & v5,
			((v[], !line_ff)  == B"XXXXXX10001") & !vcnt_reset # vcnt_reset & v4,
			((v[], !line_ff)  == B"XXXXXXX1001") & !vcnt_reset # vcnt_reset & v3,
			((v[], !line_ff)  == B"XXXXXXXX101") & !vcnt_reset # vcnt_reset & v2,
			((v[], !line_ff)  == B"XXXXXXXXX11") & !vcnt_reset # vcnt_reset & v1,
			((v[], !line_ff)  == B"XXXXXXXXXX0") & !vcnt_reset # vcnt_reset & v0
			)
			& (h[] == HCNT_ROLL_OVER);

	END IF;

	vcnt_reset = (v[] == VCNT_ROLL_OVER # cnt_reset);

	h_odd = h_odd # !pwr_up;

	h[] =  (((h[], h_odd)  == B"X100000001") & !hcnt_reset # hcnt_reset & h8,
			((h[], h_odd)  == B"XX10000001") & !hcnt_reset # hcnt_reset & h7,
			((h[], h_odd)  == B"XXX1000001") & !hcnt_reset # hcnt_reset & h6,
			((h[], h_odd)  == B"XXXX100001") & !hcnt_reset # hcnt_reset & h5,
			((h[], h_odd)  == B"XXXXX10001") & !hcnt_reset # hcnt_reset & h4,
			((h[], h_odd)  == B"XXXXXX1001") & !hcnt_reset # hcnt_reset & h3,
			((h[], h_odd)  == B"XXXXXXX101") & !hcnt_reset # hcnt_reset & h2,
			((h[], h_odd)  == B"XXXXXXXX11") & !hcnt_reset # hcnt_reset & h1,
			((h[], h_odd)  == B"XXXXXXXXX0") & !hcnt_reset # hcnt_reset & h0
			);

	hcnt_reset = (h[] == HCNT_ROLL_OVER) # pwr_up # cnt_reset;

END;
