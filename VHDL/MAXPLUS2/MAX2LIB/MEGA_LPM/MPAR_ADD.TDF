--------------------------------------------------------------------------
-- Design Name:			mpar_add										--
-- Function: 			parallel adder for partial products addition	--
-- Feature(s):			* used for both signed/unsigned	multiplication	--
--						  and hence, this module is NOT a general-		--
--						  purpose parallel adder.						--
--						* separate control over shift and pipe clocking --
---------------------------------------------------------------------------
INCLUDE "lpm_add_sub";
INCLUDE "mpar_add";

PARAMETERS 
(
	SIZE,							-- Length of input values (in bits)
	WIDTH,							-- Number of inputs
	REPRESENTATION,					-- Multiplication system: UNSIGNED/SIGNED
	LEVEL = 1,						-- Current level indicator within the tree
	TOT_LEVELS,						-- Total number of levels of the tree 
	STAGE = 1,						-- Current stage indicator within the pipeline.
	TOT_STAGES = 1,					-- Total number of pipeline stages
	INT_LATENCY,					-- internal latency of the pipeline
	PREV_SING_SIZE = SIZE-1			-- Size of the unpaired input.
);

CONSTANT BLOCKS 		= FLOOR(WIDTH DIV 2);				-- number of input pairs
CONSTANT REM_BLOCK 		= WIDTH MOD 2; 						-- number of unpaired inputs
CONSTANT TOT_BLOCKS 	= CEIL(WIDTH DIV 2);				-- total count of pairings
CONSTANT EXTRA_BITS 	= (WIDTH == 1) ? 0 : 2^(LEVEL-1);	-- number of "fall thru" bits
CONSTANT TOT_EXTRA_BITS = (WIDTH == 1) ? 0 : (2^(TOT_LEVELS-1) - 2^(LEVEL-1));	-- added extra bits at output 

-- This parameter tracks the size of "unpaired" input. This size may grow (due to
-- pairing with another input in subsequent stages) or remain constant through many
-- stages. This parameter is passed to next recursion level. 
CONSTANT SING_NODE_SIZE = (WIDTH MOD 2 == 0) ? SIZE+EXTRA_BITS : 
						  (LEVEL == 1 & REPRESENTATION == "SIGNED" ? SIZE : PREV_SING_SIZE);

-- Functions used to determine whether the clock input should be connected to
-- the registers in the current level. Need_CLK is the flag bit for that decision.
DEFINE MOD_DIST(n, d)	= ((2 * n) > d ? d - n : n);
DEFINE LATENCY_MOD(k)	= ((k * (INT_LATENCY + 1)) MOD TOT_STAGES);
CONSTANT NEED_CLK		= -((LATENCY_MOD(STAGE+1) == 0) # 
						   ((LATENCY_MOD(STAGE+1) > LATENCY_MOD(STAGE+2)) & 
			  			    (MOD_DIST(LATENCY_MOD(STAGE+1), TOT_STAGES) < 
							 MOD_DIST(LATENCY_MOD(STAGE+2), TOT_STAGES))) #
			  			   ((LATENCY_MOD(STAGE+1) < LATENCY_MOD(STAGE)) & 
						    (MOD_DIST(LATENCY_MOD(STAGE+1), TOT_STAGES) <= 
							 MOD_DIST(LATENCY_MOD(STAGE), TOT_STAGES))));

 						   
SUBDESIGN mpar_add
( 
	data[WIDTH-1..0][SIZE-1..0]			: INPUT = GND;
	cin									: INPUT = GND;
	clk, aclr							: INPUT = GND;								
 	result[SIZE+TOT_EXTRA_BITS-1..0] 	: OUTPUT;
 	clk_out, aclr_out					: OUTPUT;		 -- only for internal use
)

VARIABLE 	
	
IF WIDTH > 1 GENERATE
	IF REPRESENTATION == "UNSIGNED" GENERATE
		adder[BLOCKS-1..0]	: lpm_add_sub WITH (LPM_WIDTH = SIZE, LPM_PIPELINE = 0);
		
		IF REM_BLOCK == 1 GENERATE
			IF USED(clk) & (NEED_CLK == 1) GENERATE
				single_input_node[SING_NODE_SIZE-1..0]	: DFF;
			ELSE GENERATE
				single_input_node[SING_NODE_SIZE-1..0]	: NODE;	
			END GENERATE;
		END GENERATE;
		
	ELSE GENERATE
		IF REM_BLOCK == 1 & LEVEL == 1 GENERATE
			adder[BLOCKS..0]	: lpm_add_sub WITH (LPM_WIDTH = SIZE, LPM_PIPELINE = 0);
			
		ELSE GENERATE
			adder[BLOCKS-1..0]	: lpm_add_sub WITH (LPM_WIDTH = SIZE, LPM_PIPELINE = 0);
		END GENERATE;

		IF REM_BLOCK == 1 GENERATE
			IF LEVEL == 1 GENERATE
				IF USED(clk) & (NEED_CLK == 1) GENERATE
					single_input_node[SIZE-1..0] : DFF;
				ELSE GENERATE
					single_input_node[SIZE-1..0] : NODE;
				END GENERATE;
				
			ELSE GENERATE
				IF USED(clk) & (NEED_CLK == 1) GENERATE
					single_input_node[SING_NODE_SIZE-1..0] : DFF;
				ELSE GENERATE
					single_input_node[SING_NODE_SIZE-1..0] : NODE;
				END GENERATE;
			END GENERATE;
		END GENERATE;
	END GENERATE;
	
	IF USED(clk) & (NEED_CLK == 1) & WIDTH > 2 GENERATE
		level_result_node[BLOCKS-1..0][SIZE+EXTRA_BITS-1..0] : DFF;
	ELSE GENERATE
		level_result_node[BLOCKS-1..0][SIZE+EXTRA_BITS-1..0] : NODE;
	END GENERATE;
	
	IF TOT_BLOCKS > 1 GENERATE	
		sub_par_add		: mpar_add WITH (SIZE = SIZE+EXTRA_BITS, 
										 WIDTH = TOT_BLOCKS, 
										 REPRESENTATION = REPRESENTATION,
										 LEVEL = (LEVEL+1),
										 STAGE = (STAGE+1), 
										 TOT_LEVELS = TOT_LEVELS,
										 TOT_STAGES = TOT_STAGES,
										 INT_LATENCY = INT_LATENCY, 
										 PREV_SING_SIZE = SING_NODE_SIZE);									 
	END GENERATE;
END GENERATE;	
	
BEGIN

IF WIDTH > 1 GENERATE
	IF REPRESENTATION == "UNSIGNED" GENERATE
		-----------------------------------
		--    UNSIGNED MULTIPLICATION    --
		-----------------------------------
		FOR I IN 0 TO BLOCKS-1 GENERATE
			-- connect all dataa inputs that are paired. Within each pair, dataa input
			-- is shifted by EXTRA_BITS with respect to datab. Those EXTRA_BITS
			-- bits are fall through bits. 
			adder[I].dataa[SIZE-EXTRA_BITS-1..0] = data[I*2][SIZE-1..EXTRA_BITS];
			adder[I].dataa[SIZE-1..SIZE-EXTRA_BITS] = GND;
		
			-- level output nodes for paired inputs.
			level_result_node[I][EXTRA_BITS-1..0] = data[I*2][EXTRA_BITS-1..0];
			level_result_node[I][SIZE+EXTRA_BITS-1..EXTRA_BITS] = adder[I].result[];	
		END GENERATE;
	
		IF USED(CLK) & (NEED_CLK == 1) & WIDTH > 2 GENERATE
			level_result_node[][].(clk, clrn) = (clk, !aclr);
		END GENERATE;
		
		-- connect datab inputs, except the leftmost one. 
		IF BLOCKS > 1 GENERATE
			FOR I IN 0 TO BLOCKS-2 GENERATE
				adder[I].datab[] = data[I*2+1][];
			END GENERATE;
		END GENERATE;	
	
		-- If there is an unpaired input left, then the leftmost datab surely has
		-- received a full-length result from the previous level. Otherwise, this
		-- datab will receive a possibly shorter input from the previous adder tree level.
		IF REM_BLOCK == 1 GENERATE
			adder[BLOCKS-1].datab[] = data[(BLOCKS-1)*2+1][];
		ELSE GENERATE
			adder[BLOCKS-1].datab[PREV_SING_SIZE-1..0] = data[(BLOCKS-1)*2+1][PREV_SING_SIZE-1..0];
			IF PREV_SING_SIZE < SIZE GENERATE
				-- Extend the input if its shorter than others.
				adder[BLOCKS-1].datab[SIZE-1..PREV_SING_SIZE] = GND;
			END GENERATE;
		END GENERATE;

		-- If there's an unpaired input, connect it to an internal register or node.
		-- It will pass through this level without any change in size.
		IF REM_BLOCK == 1 GENERATE
			single_input_node[] = data[WIDTH-1][SING_NODE_SIZE-1..0];
			
			IF USED(CLK) & (NEED_CLK == 1) GENERATE
				single_input_node[].(clk, clrn) = (clk, !aclr);
			END GENERATE;
		END GENERATE;
		
		-- If more than one total pair (which includes the unpaired input) is left
		-- in this level, we will need another level of adders.
		IF TOT_BLOCKS > 1 GENERATE
			FOR I IN 0 TO BLOCKS-1 GENERATE
			 	sub_par_add.data[I][] = level_result_node[I][];
			END GENERATE;
			
			IF REM_BLOCK == 1 GENERATE
				sub_par_add.data[BLOCKS][SING_NODE_SIZE-1..0] = single_input_node[];
			END GENERATE;
			
			result[] = sub_par_add.result[];
			
			IF USED(clk) GENERATE
				sub_par_add.(clk, aclr) = (clk, aclr);	
				clk_out = sub_par_add.clk_out;
				aclr_out = sub_par_add.aclr_out;
			END GENERATE;
				
		ELSE GENERATE
			-- Only two inputs were fed into the present stage. The result of addition
			-- is taken from the stage's only adder's output.
			clk_out = clk;
			aclr_out = aclr;
			result[] = level_result_node[0][];
		END GENERATE;
	
	ELSE GENERATE
		-----------------------------------
		--    SIGNED MULTIPLICATION      --
		-----------------------------------
		-- The situation is similar for SIGNED case with two major differences:
		-- 1) sign extensions are performed after shifting of inputs.
		-- 2) The first level of tree (LEVEL = 1) will have an extra adder to implement
		-- 	  2's complement "negation", if the number of inputs is an odd number.
		--    For even-numbered inputs, the leftmost pairing adder will use the carry input
		--    to do the negation. 
		FOR I IN 0 TO BLOCKS-1 GENERATE
			IF LEVEL == 1 GENERATE
				adder[I].dataa[SIZE-EXTRA_BITS-2..0] = data[I*2][SIZE-2..EXTRA_BITS];
				adder[I].dataa[SIZE-1..SIZE-EXTRA_BITS-1] = data[I*2][SIZE-2];
			ELSE GENERATE
				adder[I].dataa[SIZE-EXTRA_BITS-1..0] = data[I*2][SIZE-1..EXTRA_BITS];
				adder[I].dataa[SIZE-1..SIZE-EXTRA_BITS] = data[I*2][SIZE-1];
			END GENERATE;
			
			level_result_node[I][EXTRA_BITS-1..0] = data[I*2][EXTRA_BITS-1..0];
			level_result_node[I][SIZE+EXTRA_BITS-1..EXTRA_BITS] = adder[I].result[];	
		END GENERATE;
	
		IF USED(CLK) & (NEED_CLK == 1) & WIDTH > 2 GENERATE
			level_result_node[][].(clk, clrn) = (clk, !aclr);
		END GENERATE;
		
		IF BLOCKS > 1 GENERATE
			FOR I IN 0 TO BLOCKS-2 GENERATE
				IF LEVEL == 1 GENERATE
					adder[I].datab[SIZE-2..0] = data[I*2+1][SIZE-2..0];
					adder[I].datab[SIZE-1] = data[I*2+1][SIZE-2];				
				ELSE GENERATE
					adder[I].datab[] = data[I*2+1][];
				END GENERATE;
			END GENERATE;
		END GENERATE;	
	
		IF LEVEL == 1 GENERATE
			adder[BLOCKS-1].datab[SIZE-2..0] = data[(BLOCKS-1)*2+1][SIZE-2..0];
			adder[BLOCKS-1].datab[SIZE-1] = data[(BLOCKS-1)*2+1][SIZE-2];
			
		ELSE GENERATE
 			IF REM_BLOCK == 1 GENERATE
 				adder[BLOCKS-1].datab[] = data[(BLOCKS-1)*2+1][];
 				
 			ELSE GENERATE
				adder[BLOCKS-1].datab[PREV_SING_SIZE-1..0] = data[(BLOCKS-1)*2+1][PREV_SING_SIZE-1..0];
				IF PREV_SING_SIZE < SIZE GENERATE
					adder[BLOCKS-1].datab[SIZE-1..PREV_SING_SIZE] = data[(BLOCKS-1)*2+1][PREV_SING_SIZE-1];
				END GENERATE;
			END GENERATE;
		END GENERATE;
		
		IF REM_BLOCK == 1 GENERATE
			IF LEVEL == 1 GENERATE
				adder[BLOCKS].dataa[SIZE-2..0] = data[WIDTH-1][SIZE-2..0];
				adder[BLOCKS].dataa[SIZE-1] = data[WIDTH-1][SIZE-2];				
				adder[BLOCKS].datab[SIZE-1..1] = GND;
				adder[BLOCKS].datab[0] = cin;					
					
				single_input_node[] = adder[BLOCKS].result[SIZE-1..0];
			ELSE GENERATE
				single_input_node[SING_NODE_SIZE-1..0] = data[WIDTH-1][SING_NODE_SIZE-1..0];	
			END GENERATE;
			
			IF USED(CLK) & (NEED_CLK == 1) GENERATE
				single_input_node[].(clk, clrn) = (clk, !aclr);
			END GENERATE;
		
		ELSE GENERATE
			adder[BLOCKS-1].cin = cin;
		END GENERATE;

		IF TOT_BLOCKS > 1 GENERATE
			FOR I IN 0 TO BLOCKS-1 GENERATE
		 		sub_par_add.data[I][] = level_result_node[I][];
			END GENERATE;
		
			IF REM_BLOCK == 1 GENERATE
				IF LEVEL == 1 GENERATE
					sub_par_add.data[BLOCKS][SIZE-1..0] = single_input_node[SIZE-1..0];
					
				ELSE GENERATE
					sub_par_add.data[BLOCKS][SING_NODE_SIZE-1..0] = single_input_node[];
				END GENERATE;
			END GENERATE;
			
			result[] = sub_par_add.result[];
			
			IF USED(clk) GENERATE
				sub_par_add.(clk, aclr) = (clk, aclr);	
				clk_out = sub_par_add.clk_out;
				aclr_out = sub_par_add.aclr_out;
			END GENERATE;
				
		ELSE GENERATE
			clk_out = clk;
			aclr_out = aclr;
			result[] = level_result_node[0][];
		END GENERATE;
	END GENERATE;
ELSE GENERATE
	result[] = data[0][];
END GENERATE;	
END;
